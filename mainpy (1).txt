import discord
from discord import app_commands, ui, ButtonStyle, File, Interaction, Embed, Message, Attachment
import os
import asyncio
import random
from datetime import datetime, timedelta, timezone
import json
import aiohttp
import threading
from io import BytesIO
import re
import time as time_module # time modÃ¼lÃ¼nÃ¼ time_module olarak alÄ±yoruz, Ã§akÄ±ÅŸmayÄ± Ã¶nlemek iÃ§in
import math
import logging
import platform
from PIL import Image
from urllib.parse import urlparse, quote, unquote
from dotenv import load_dotenv

# PDF iÅŸleme iÃ§in
try:
    from pypdf2 import PdfReader
except ImportError:
    PdfReader = None # EÄŸer kurulu deÄŸilse hata vermesin, komut iÃ§inde kontrol edilsin

import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold, GenerationConfig

# FastAPI (Health Check iÃ§in)
from fastapi import FastAPI
import uvicorn

# --- Ortam DeÄŸiÅŸkenlerini YÃ¼kle ---
load_dotenv()

# --- Temel Loglama AyarlarÄ± ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s:%(levelname)s:%(name)s: %(message)s')
logger = logging.getLogger('discord_bot')

# --- Discord Bot AyarlarÄ± ---
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.reactions = True
# intents.voice_states = True # MÃ¼zik kaldÄ±rÄ±ldÄ±ÄŸÄ± iÃ§in buna gerek kalmayabilir, ama bazÄ± VC iÅŸlemleri iÃ§in kalabilir. Åimdilik bÄ±rakÄ±yorum.
client = discord.Client(intents=intents)
tree = app_commands.CommandTree(client)

# --- FastAPI UygulamasÄ± (Health Check iÃ§in) ---
fastapi_app = FastAPI() # 'app' yerine 'fastapi_app' kullanarak olasÄ± Ã§akÄ±ÅŸmalarÄ± Ã¶nle

@fastapi_app.get("/")
async def root():
    return {"message": f"{BOT_NAME} Aktif! Versiyon: {VERSION}"}

# --- Global DeÄŸiÅŸkenler ve Ayarlar ---
PREFIX = "."
BOT_NAME = "OmniVerse AI"
VERSION = "1.0 BETA"
DEVELOPER_IDS = [YOUR_DEVELOPER_USER_ID_HERE] # Kendi Discord kullanÄ±cÄ± ID'nizi buraya ekleyin (int olarak)

# API AnahtarlarÄ±
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
TENOR_API_KEY = os.environ.get("TENOR_API_KEY") # GIF'ler iÃ§in

# Dosya YollarÄ±
USER_DATA_FILE = "user_data.json"
PREMIUM_DATA_FILE = "premium.json"
LANGUAGES_FILE = "languages.json"
GUILD_PERSONALITIES_FILE = "guild_personalities.json" # Sunucuya Ã¶zel kiÅŸilikler iÃ§in

# Veri Saklama DeÄŸiÅŸkenleri
user_data = {}
premium_users = {}
language_strings = {}
guild_personalities = {}

# Emoji YÃ¶netimi
EMOJIS = {
    "loading": "ğŸ”„",
    "success": "âœ…",
    "error": "âŒ",
    "info": "â„¹ï¸",
    "credit": "ğŸª™",
    "premium": "â­",
    "ai": "ğŸ¤–",
    "link": "ğŸ”—",
    "file": "ğŸ“„",
    "image": "ğŸ–¼ï¸",
    "pdf": "ğŸ“œ",
    "txt": "ğŸ“",
    "wait": "â³",
    "party": "ğŸ‰",
    "warning": "âš ï¸",
    "question": "â“",
    "translate": "ğŸŒ",
    "summarize": "ğŸ“‹",
    "analyze": "ğŸ“Š",
    "game": "ğŸ®",
    "flag_en": "ğŸ‡¬ğŸ‡§", "flag_tr": "ğŸ‡¹ğŸ‡·", "flag_fr": "ğŸ‡«ğŸ‡·", "flag_de": "ğŸ‡©ğŸ‡ª", "flag_es": "ğŸ‡ªğŸ‡¸",
    "flag_ar": "ğŸ‡¸ğŸ‡¦", "flag_ja": "ğŸ‡¯ğŸ‡µ", "flag_zh": "ğŸ‡¨ğŸ‡³", "flag_ru": "ğŸ‡·ğŸ‡º", "flag_pt": "ğŸ‡µğŸ‡¹",
    "flag_it": "ğŸ‡®ğŸ‡¹", "flag_ko": "ğŸ‡°ğŸ‡·", "flag_hi": "ğŸ‡®ğŸ‡³", "flag_nl": "ğŸ‡³ğŸ‡±", "flag_pl": "ğŸ‡µğŸ‡±",
}

SUPPORTED_LANGUAGES = {
    "en": {"name": "English", "flag": EMOJIS["flag_en"]},
    "tr": {"name": "TÃ¼rkÃ§e", "flag": EMOJIS["flag_tr"]},
    "fr": {"name": "FranÃ§ais", "flag": EMOJIS["flag_fr"]},
    "de": {"name": "Deutsch", "flag": EMOJIS["flag_de"]},
    "es": {"name": "EspaÃ±ol", "flag": EMOJIS["flag_es"]},
    "ar": {"name": "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "flag": EMOJIS["flag_ar"]},
    "ja": {"name": "æ—¥æœ¬èª", "flag": EMOJIS["flag_ja"]},
    "zh-CN": {"name": "ç®€ä½“ä¸­æ–‡", "flag": EMOJIS["flag_zh"]}, # Ã‡ince (BasitleÅŸtirilmiÅŸ)
    "ru": {"name": "Ğ ÑƒÑÑĞºĞ¸Ğ¹", "flag": EMOJIS["flag_ru"]},
    "pt-BR": {"name": "PortuguÃªs (Brasil)", "flag": EMOJIS["flag_pt"]}, # Portekizce (Brezilya)
    "it": {"name": "Italiano", "flag": EMOJIS["flag_it"]},
    "ko": {"name": "í•œêµ­ì–´", "flag": EMOJIS["flag_ko"]},
    "hi": {"name": "à¤¹à¤¿à¤¨à¥à¤¦à¥€", "flag": EMOJIS["flag_hi"]},
    "nl": {"name": "Nederlands", "flag": EMOJIS["flag_nl"]},
    "pl": {"name": "Polski", "flag": EMOJIS["flag_pl"]},
}


# --- Veri YÃ¶netimi FonksiyonlarÄ± ---
def load_json_data(filepath, default_data=None):
    if default_data is None:
        default_data = {}
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        logger.warning(f"{filepath} bulunamadÄ±, varsayÄ±lan veri ile oluÅŸturuluyor.")
        save_json_data(filepath, default_data)
        return default_data
    except json.JSONDecodeError:
        logger.error(f"{filepath} dosyasÄ± bozuk. VarsayÄ±lan veri ile Ã¼zerine yazÄ±lacak.")
        save_json_data(filepath, default_data) # Bozuksa Ã¼zerine yaz
        return default_data

def save_json_data(filepath, data):
    try:
        temp_filepath = f"{filepath}.tmp"
        with open(temp_filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        os.replace(temp_filepath, filepath)
    except Exception as e:
        logger.error(f"{filepath} dosyasÄ± kaydedilemedi: {e}")

def get_user_data_entry(user_id: int):
    user_id_str = str(user_id)
    if user_id_str not in user_data:
        user_data[user_id_str] = {
            "credits": 0, # BaÅŸlangÄ±Ã§ta 0, ilk kredi verme fonksiyonu ile artÄ±rÄ±lacak
            "last_daily_credit_timestamp": None,
            "language": "en", # VarsayÄ±lan dil
            "initial_credit_granted": False,
            "personality_prompt": None, # KullanÄ±cÄ±ya Ã¶zel AI kiÅŸiliÄŸi
            "chat_personality_active": False
        }
        # Yeni kullanÄ±cÄ± iÃ§in ilk krediyi ver
        if not user_data[user_id_str]["initial_credit_granted"]:
            user_data[user_id_str]["credits"] = 10
            user_data[user_id_str]["initial_credit_granted"] = True
            logger.info(f"KullanÄ±cÄ± {user_id_str} iÃ§in 10 baÅŸlangÄ±Ã§ kredisi verildi.")
        save_json_data(USER_DATA_FILE, user_data)
    return user_data[user_id_str]

def is_premium_user(user_id: int):
    return str(user_id) in premium_users

def get_guild_personality(guild_id: int):
    guild_id_str = str(guild_id)
    return guild_personalities.get(guild_id_str)

# --- Dil YÃ¶netimi ---
def load_translations():
    global language_strings
    default_lang_data = {
        "en": {
            "error_generic": "An error occurred.",
            "error_no_permission": "You do not have permission to use this command.",
            "error_bot_no_permission": "I don't have the required permissions: `{permissions}`.",
            "error_cooldown": "This command is on cooldown. Try again in **{seconds:.1f}s**.",
            "error_not_enough_credits": f"{EMOJIS['credit']} You don't have enough credits (1 required). Current: {{user_credits}}.",
            "credits_exhausted_message": f"{EMOJIS['error']} You've run out of credits! Your daily credits will reset soon.\n"
                                         f"Alternatively, upgrade to {EMOJIS['premium']} **Premium** for **$4.99** for unlimited access: [Your Premium Purchase Link Here]\n"
                                         f"Or, vote for us on Top.gg for extra credits: [Your Top.gg Vote Link Here]",
            "command_cost_message": f"{EMOJIS['credit']} This command cost 1 credit. Remaining: {{user_credits}}.",
            "daily_credits_granted": f"{EMOJIS['party']} You have received your **10** daily credits! Current: {{user_credits}}.",
            "initial_credits_granted": f"{EMOJIS['party']} Welcome! You have received **10** initial credits!",
            "ai_thinking": f"{EMOJIS['ai']} OmniVerse AI is thinking...",
            "ai_response_delayed_free": f"{EMOJIS['wait']} (Free user delay: {{delay_seconds}}s)",
            "tictactoe_vs_ai_win": f"{EMOJIS['party']} You beat OmniVerse AI and earned 1 {EMOJIS['credit']} credit!",
            "language_set": f"{EMOJIS['success']} Your language has been set to **{{language_name}}**.",
            "premium_command_title": f"{EMOJIS['premium']} OmniVerse AI Premium",
            "premium_command_description": ("Unlock the full potential of OmniVerse AI!\n\n"
                                           f"**Benefits:**\n"
                                           f"- {EMOJIS['success']} Unlimited AI command usage (no credit limits).\n"
                                           f"- {EMOJIS['success']} Faster AI response times.\n"
                                           f"- {EMOJIS['success']} Access to exclusive premium-only features (coming soon).\n"
                                           f"- {EMOJIS['success']} Priority support.\n\n"
                                           f"Upgrade now for just **$4.99**!"),
            "premium_command_link_text": "Click here to become a Premium User!",
            "personality_set_success": f"{EMOJIS['success']} AI personality for direct mentions in this server has been updated. Use `/editpersonality disable` to turn it off.",
            "personality_disabled_success": f"{EMOJIS['success']} Custom AI personality for direct mentions in this server has been disabled.",
            "personality_no_active": "No active custom personality set for direct mentions in this server.",
            "error_file_too_large": f"{EMOJIS['error']} The uploaded file is too large (Max: {{max_size_mb}}MB).",
            "error_unsupported_file": f"{EMOJIS['error']} Unsupported file type: `{{file_type}}`. Supported: PDF, TXT.",
            "error_pdf_read": f"{EMOJIS['error']} Could not read text from the PDF file.",
            "command_analyzeuser_description": "Analyzes the recent chat messages of a user.",
            "command_analyzechat_description": "Analyzes recent messages in the current channel.",
            "command_summarize_description": "Summarizes text, links, or uploaded documents.",
            "command_translate_description": "Translates text or content from images/links to a specified language.",
            "command_analyzedocument_description": "Analyzes an uploaded document (PDF, TXT).",
            "command_tictactoe_description": "Play Tic-Tac-Toe against AI or another user.",
            "command_language_description": "Set your preferred language for bot responses.",
            "command_premium_description": "Information about OmniVerse AI Premium.",
            "command_editpersonality_description": "Edit the AI's personality for direct mentions in this server.",
            "command_editpersonality_option_action_description": "Enable, disable, or view the current personality.",
            "command_editpersonality_option_prompt_description": "The personality prompt for the AI (if enabling).",
            # ... DiÄŸer genel mesajlar
        },
        "tr": {
            "error_generic": "Bir hata oluÅŸtu.",
            "error_no_permission": "Bu komutu kullanma yetkiniz yok.",
            "error_bot_no_permission": "Gerekli yetkilere sahip deÄŸilim: `{permissions}`.",
            "error_cooldown": "Bu komut bekleme sÃ¼resinde. **{seconds:.1f} saniye** sonra tekrar deneyin.",
            "error_not_enough_credits": f"{EMOJIS['credit']} Yeterli krediniz yok (1 gerekli). Mevcut: {{user_credits}}.",
            "credits_exhausted_message": f"{EMOJIS['error']} Kredileriniz tÃ¼kendi! GÃ¼nlÃ¼k kredileriniz yakÄ±nda yenilenecek.\n"
                                         f"Alternatif olarak, sÄ±nÄ±rsÄ±z eriÅŸim iÃ§in sadece **4.99$** karÅŸÄ±lÄ±ÄŸÄ±nda {EMOJIS['premium']} **Premium**'a yÃ¼kseltin: [Premium SatÄ±n Alma Linkiniz Buraya]\n"
                                         f"Veya ekstra kredi iÃ§in Top.gg'de bize oy verin: [Top.gg Oy Verme Linkiniz Buraya]",
            "command_cost_message": f"{EMOJIS['credit']} Bu komut 1 kredi harcadÄ±. Kalan: {{user_credits}}.",
            "daily_credits_granted": f"{EMOJIS['party']} **10** gÃ¼nlÃ¼k krediniz verildi! Mevcut: {{user_credits}}.",
            "initial_credits_granted": f"{EMOJIS['party']} HoÅŸ geldiniz! **10** baÅŸlangÄ±Ã§ krediniz verildi!",
            "ai_thinking": f"{EMOJIS['ai']} OmniVerse AI dÃ¼ÅŸÃ¼nÃ¼yor...",
            "ai_response_delayed_free": f"{EMOJIS['wait']} (Ãœcretsiz kullanÄ±cÄ± gecikmesi: {{delay_seconds}}s)",
            "tictactoe_vs_ai_win": f"{EMOJIS['party']} OmniVerse AI'Ä± yendin ve 1 {EMOJIS['credit']} kredi kazandÄ±n!",
            "language_set": f"{EMOJIS['success']} Diliniz **{{language_name}}** olarak ayarlandÄ±.",
            "premium_command_title": f"{EMOJIS['premium']} OmniVerse AI Premium",
            "premium_command_description": ("OmniVerse AI'Ä±n tÃ¼m potansiyelini aÃ§Ä±ÄŸa Ã§Ä±karÄ±n!\n\n"
                                           f"**Avantajlar:**\n"
                                           f"- {EMOJIS['success']} SÄ±nÄ±rsÄ±z AI komut kullanÄ±mÄ± (kredi limiti yok).\n"
                                           f"- {EMOJIS['success']} Daha hÄ±zlÄ± AI yanÄ±t sÃ¼releri.\n"
                                           f"- {EMOJIS['success']} Ã–zel premium Ã¶zelliklere eriÅŸim (yakÄ±nda).\n"
                                           f"- {EMOJIS['success']} Ã–ncelikli destek.\n\n"
                                           f"Sadece **4.99$** karÅŸÄ±lÄ±ÄŸÄ±nda ÅŸimdi yÃ¼kseltin!"),
            "premium_command_link_text": "Premium KullanÄ±cÄ± Olmak Ä°Ã§in TÄ±klayÄ±n!",
            "personality_set_success": f"{EMOJIS['success']} Bu sunucudaki doÄŸrudan etiketlemeler iÃ§in AI kiÅŸiliÄŸi gÃ¼ncellendi. Kapatmak iÃ§in `/editpersonality disable` kullanÄ±n.",
            "personality_disabled_success": f"{EMOJIS['success']} Bu sunucudaki doÄŸrudan etiketlemeler iÃ§in Ã¶zel AI kiÅŸiliÄŸi devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±.",
            "personality_no_active": "Bu sunucudaki doÄŸrudan etiketlemeler iÃ§in aktif Ã¶zel kiÅŸilik ayarÄ± yok.",
            "error_file_too_large": f"{EMOJIS['error']} YÃ¼klenen dosya Ã§ok bÃ¼yÃ¼k (Maks: {{max_size_mb}}MB).",
            "error_unsupported_file": f"{EMOJIS['error']} Desteklenmeyen dosya tÃ¼rÃ¼: `{{file_type}}`. Desteklenenler: PDF, TXT.",
            "error_pdf_read": f"{EMOJIS['error']} PDF dosyasÄ±ndan metin okunamadÄ±.",
            "command_analyzeuser_description": "Bir kullanÄ±cÄ±nÄ±n son sohbet mesajlarÄ±nÄ± analiz eder.",
            "command_analyzechat_description": "Mevcut kanaldaki son mesajlarÄ± analiz eder.",
            "command_summarize_description": "Metinleri, baÄŸlantÄ±larÄ± veya yÃ¼klenen belgeleri Ã¶zetler.",
            "command_translate_description": "Metinleri veya gÃ¶rsellerdeki/baÄŸlantÄ±lardaki iÃ§eriÄŸi belirtilen bir dile Ã§evirir.",
            "command_analyzedocument_description": "YÃ¼klenmiÅŸ bir belgeyi (PDF, TXT) analiz eder.",
            "command_tictactoe_description": "AI'a veya baÅŸka bir kullanÄ±cÄ±ya karÅŸÄ± Tic-Tac-Toe oynayÄ±n.",
            "command_language_description": "Bot yanÄ±tlarÄ± iÃ§in tercih ettiÄŸiniz dili ayarlayÄ±n.",
            "command_premium_description": "OmniVerse AI Premium hakkÄ±nda bilgi.",
            "command_editpersonality_description": "Bu sunucudaki doÄŸrudan etiketlemeler iÃ§in AI'nÄ±n kiÅŸiliÄŸini dÃ¼zenleyin.",
            "command_editpersonality_option_action_description": "Mevcut kiÅŸiliÄŸi etkinleÅŸtirin, devre dÄ±ÅŸÄ± bÄ±rakÄ±n veya gÃ¶rÃ¼ntÃ¼leyin.",
            "command_editpersonality_option_prompt_description": "AI iÃ§in kiÅŸilik istemi (etkinleÅŸtiriyorsanÄ±z).",
        }
        # DiÄŸer diller iÃ§in de buraya eklenecek
    }
    loaded_strings = load_json_data(LANGUAGES_FILE, default_lang_data)
    # VarsayÄ±lan verideki eksik dilleri veya anahtarlarÄ± tamamla
    for lang_code, default_translations in default_lang_data.items():
        if lang_code not in loaded_strings:
            loaded_strings[lang_code] = default_translations.copy()
        else:
            for key, value in default_translations.items():
                if key not in loaded_strings[lang_code]:
                    loaded_strings[lang_code][key] = value
    language_strings = loaded_strings
    save_json_data(LANGUAGES_FILE, language_strings)


def get_lang_string(user_id: int, key: str, **kwargs):
    data = get_user_data_entry(user_id)
    lang_code = data.get("language", "en")

    # Ã‡ince iÃ§in Ã¶zel durum, zh-CN veya zh-TW olabilir, zh ile eÅŸleÅŸtir
    if lang_code.startswith("zh") and lang_code not in language_strings:
        if "zh-CN" in language_strings: lang_code = "zh-CN"
        elif "zh-TW" in language_strings: lang_code = "zh-TW"

    # Portekizce iÃ§in Ã¶zel durum
    if lang_code.startswith("pt") and lang_code not in language_strings:
        if "pt-BR" in language_strings: lang_code = "pt-BR"
        elif "pt-PT" in language_strings: lang_code = "pt-PT"


    translation = language_strings.get(lang_code, language_strings.get("en", {})).get(key)

    if translation is None: # EÄŸer Ã§eviri bulunamazsa Ä°ngilizceye fallback yap
        translation = language_strings.get("en", {}).get(key, f"[{key.upper()}_NOT_FOUND]")

    try:
        return translation.format(**kwargs)
    except KeyError as e_format: # Formatlama hatasÄ± olursa
        logger.error(f"Dil formatlama hatasÄ±: Dil={lang_code}, Anahtar={key}, kwargs={kwargs}, Hata={e_format}")
        return language_strings.get("en", {}).get(key, f"[{key.upper()}_FORMAT_ERROR]") # HatalÄ± format yerine Ä°ngilizce ham metni gÃ¶nder
    except Exception as e:
        logger.error(f"Dil string getirme hatasÄ±: {e}")
        return f"[{key.upper()}_ERROR]"

def get_localized_description(key_base: str, lang_code: str):
    """ Slash komut aÃ§Ä±klamalarÄ± iÃ§in yerelleÅŸtirilmiÅŸ string alÄ±r. """
    # Bu fonksiyon, 'command_X_description' formatÄ±ndaki anahtarlarÄ± kullanÄ±r.
    return language_strings.get(lang_code, {}).get(f"command_{key_base}_description", None)

def get_all_localized_descriptions(key_base: str):
    """ TÃ¼m diller iÃ§in yerelleÅŸtirilmiÅŸ aÃ§Ä±klamalarÄ± dÃ¶ner. """
    localizations = {}
    for lang_code in SUPPORTED_LANGUAGES.keys():
        desc = get_localized_description(key_base, lang_code)
        if desc:
            # Discord'un beklediÄŸi format: zh-CN, zh-TW, pt-BR
            discord_lang_code = lang_code
            localizations[discord_lang_code] = desc
    return localizations if localizations else None

# --- Gemini AI YapÄ±landÄ±rmasÄ± ve FonksiyonlarÄ± ---
gemini_model_instance = None
KULLANILACAK_GEMINI_MODELI = 'gemini-1.5-flash-latest' # Veya 'gemini-pro' (metin), 'gemini-pro-vision' (multimodal)

DEFAULT_GEMINI_SAFETY_SETTINGS = {
    HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_ONLY_HIGH,
    HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
    HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
    HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
}

# KiÅŸilik modu iÃ§in daha esnek ayarlar (sunucu sahibi tarafÄ±ndan belirlenen kiÅŸilik iÃ§in)
PERSONALITY_MODE_SAFETY_SETTINGS = {
    HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
    HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
    HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
    HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
}

DEFAULT_GENERATION_CONFIG = GenerationConfig(
    # temperature=0.7, # YaratÄ±cÄ±lÄ±k ayarÄ±, isteÄŸe baÄŸlÄ±
    max_output_tokens=2000 # YanÄ±t uzunluÄŸu iÃ§in token limiti
)

if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        gemini_model_instance = genai.GenerativeModel(
            KULLANILACAK_GEMINI_MODELI,
            # safety_settings ve generation_config generate_content_async iÃ§inde dinamik olarak verilecek
        )
        logger.info(f"Google Gemini AI ({KULLANILACAK_GEMINI_MODELI}) baÅŸarÄ±yla yÃ¼klendi.")
    except Exception as e:
        logger.error(f"Google Gemini AI yapÄ±landÄ±rma hatasÄ± ({KULLANILACAK_GEMINI_MODELI}): {e}")
        gemini_model_instance = None
else:
    logger.warning("GEMINI_API_KEY ortam deÄŸiÅŸkeni bulunamadÄ±. AI Ã¶zellikleri devre dÄ±ÅŸÄ±.")


async def ask_gemini_core(
    prompt_parts: list, # Hem metin hem de Image objeleri iÃ§erebilir
    user_id: int,
    target_language_code: str = "en",
    apply_guild_chat_personality: bool = False, # Sadece mention sohbetlerinde aktif olacak sunucu kiÅŸiliÄŸi
    guild_id: int | None = None
):
    if not gemini_model_instance:
        return get_lang_string(user_id, "error_ai_module_unavailable", ai_name="Gemini")

    user_is_premium = is_premium_user(user_id)
    delay_seconds = 1.25 if user_is_premium else 3.5
    await asyncio.sleep(delay_seconds)

    current_safety_settings = DEFAULT_GEMINI_SAFETY_SETTINGS
    personality_system_prompt = f"You are {BOT_NAME}, a helpful AI assistant. You will never say you are a language model or an AI model by Google or OpenAI."
    
    # Sunucuya Ã¶zel kiÅŸilik (sadece mention sohbetleri iÃ§in)
    if apply_guild_chat_personality and guild_id:
        g_personality_data = get_guild_personality(guild_id)
        if g_personality_data and g_personality_data.get("active") and g_personality_data.get("prompt"):
            personality_system_prompt += f"\n\nSERVER-SPECIFIC PERSONALITY INSTRUCTION (Strictly Follow This for this interaction only):\n{g_personality_data['prompt']}\n(End of server-specific instruction)"
            current_safety_settings = PERSONALITY_MODE_SAFETY_SETTINGS # KiÅŸilik iÃ§in daha esnek gÃ¼venlik
            logger.info(f"Guild personality active for user {user_id} in guild {guild_id}.")


    # Dil talimatÄ±
    target_language_name = SUPPORTED_LANGUAGES.get(target_language_code, {}).get("name", "English")
    language_instruction = f"\nIMPORTANT: Respond in {target_language_name} (language code: {target_language_code})."
    personality_system_prompt += language_instruction

    # API'ye gÃ¶nderilecek son prompt parÃ§alarÄ±
    final_api_prompt_parts = [personality_system_prompt]

    # KullanÄ±cÄ±nÄ±n asÄ±l prompt'unu ve resimlerini ekle
    has_text_input = False
    for part in prompt_parts:
        if isinstance(part, str) and part.strip():
            final_api_prompt_parts.append(part)
            has_text_input = True
        elif isinstance(part, Image.Image): # PIL Image objesi
            final_api_prompt_parts.append(part)
        elif isinstance(part, dict) and "mime_type" in part and "data" in part: # Veri geldiÄŸinde PIL'e Ã§evir
            try:
                pil_image = Image.open(BytesIO(part["data"]))
                final_api_prompt_parts.append(pil_image)
            except Exception as e_pil:
                logger.error(f"Multimodal iÃ§in resim PIL Image'a Ã§evrilirken hata: {e_pil}")
                final_api_prompt_parts.append("(An image was provided but could not be processed.)")


    if not has_text_input and any(isinstance(p, Image.Image) for p in final_api_prompt_parts):
        # Sadece resim varsa ve kullanÄ±cÄ± metin girmemiÅŸse, varsayÄ±lan bir istem ekle
        final_api_prompt_parts.append("Please describe or analyze the provided image(s).")

    if len(final_api_prompt_parts) == 1 and final_api_prompt_parts[0] == personality_system_prompt:
        # Sadece sistem promptu varsa (kullanÄ±cÄ±dan iÃ§erik gelmediyse)
        return "It seems you didn't provide any content for me to process."


    try:
        # Loglama iÃ§in prompt'un metin kÄ±smÄ±nÄ± al
        log_prompt_text_parts = [p for p in final_api_prompt_parts if isinstance(p, str)]
        log_prompt_preview = " | ".join(log_prompt_text_parts)[:200]
        logger.info(f"Gemini ({KULLANILACAK_GEMINI_MODELI}) Request (User: {user_id}, Lang: {target_language_code}, GuildPers: {apply_guild_chat_personality}, Premium: {user_is_premium}). Prompt Preview: {log_prompt_preview}...")

        response = await asyncio.wait_for(
            gemini_model_instance.generate_content_async(
                final_api_prompt_parts,
                safety_settings=current_safety_settings,
                generation_config=DEFAULT_GENERATION_CONFIG
            ),
            timeout=90.0 # Multimodal iÃ§in daha uzun timeout
        )

        if not response.parts:
            block_reason = response.prompt_feedback.block_reason if response.prompt_feedback else "Unknown"
            block_reason_name = getattr(block_reason, 'name', str(block_reason))
            logger.warning(f"Gemini boÅŸ yanÄ±t (User: {user_id}). Sebep: {block_reason_name}.")
            if "SAFETY" in block_reason_name.upper():
                return get_lang_string(user_id, "error_ai_safety_filter")
            return get_lang_string(user_id, "error_ai_no_response")

        ai_text = response.text.strip()
        # YanÄ±tlarÄ±n aÅŸÄ±rÄ± uzun olmasÄ±nÄ± engellemek iÃ§in (kelime bazlÄ±)
        # max_words = 300 # Ä°steÄŸe baÄŸlÄ±
        # words = ai_text.split()
        # if len(words) > max_words:
        #     ai_text = " ".join(words[:max_words]) + "..."
        #     logger.info(f"Gemini yanÄ±tÄ± {max_words} kelimeye kÄ±saltÄ±ldÄ±.")
            
        return ai_text

    except asyncio.TimeoutError:
        logger.warning(f"Gemini isteÄŸi zaman aÅŸÄ±mÄ±na uÄŸradÄ± (User: {user_id}).")
        return get_lang_string(user_id, "error_ai_timeout")
    except Exception as e:
        logger.error(f"Google Gemini API hatasÄ± (User: {user_id}): {e}", exc_info=True)
        err_str = str(e).lower()
        if "api key not valid" in err_str: return get_lang_string(user_id, "error_ai_invalid_key")
        elif "blocked" in err_str or "safety" in err_str: return get_lang_string(user_id, "error_ai_safety_filter_generic")
        elif "quota" in err_str or "rate limit" in err_str: return get_lang_string(user_id, "error_ai_quota_exceeded")
        elif "resource_exhausted" in err_str or "model_not_found" in err_str:
             return get_lang_string(user_id, "error_ai_model_issue", model_name=KULLANILACAK_GEMINI_MODELI)
        elif "image" in err_str or "mime_type" in err_str or "unsupported" in err_str:
             return get_lang_string(user_id, "error_ai_unsupported_image")
        return get_lang_string(user_id, "error_ai_comms_failed", error_message=str(e)[:100])


# --- Medya Ä°ÅŸleme YardÄ±mcÄ± FonksiyonlarÄ± ---
async def fetch_url_content(session: aiohttp.ClientSession, url: str):
    """Bir URL'den iÃ§erik (metin ve resim URL'si) Ã§ekmeye Ã§alÄ±ÅŸÄ±r."""
    try:
        async with session.get(url, timeout=10) as response:
            if response.status == 200:
                content_type = response.headers.get("Content-Type", "").lower()
                if "text/html" in content_type:
                    html_content = await response.text()
                    # Basit OpenGraph ve baÅŸlÄ±k/aÃ§Ä±klama Ã§Ä±karma
                    title_match = re.search(r"<title>(.*?)</title>", html_content, re.IGNORECASE | re.DOTALL)
                    og_title_match = re.search(r'<meta\s+(?:property|name)="og:title"\s+content="(.*?)"', html_content, re.IGNORECASE)
                    og_desc_match = re.search(r'<meta\s+(?:property|name)="og:description"\s+content="(.*?)"', html_content, re.IGNORECASE)
                    og_image_match = re.search(r'<meta\s+(?:property|name)="og:image"\s+content="(.*?)"', html_content, re.IGNORECASE)

                    title = og_title_match.group(1) if og_title_match else (title_match.group(1) if title_match else "No Title")
                    description = og_desc_match.group(1) if og_desc_match else "No Description"
                    image_url = og_image_match.group(1) if og_image_match else None
                    
                    # Metin iÃ§eriÄŸini daha iyi Ã§Ä±karmak iÃ§in kÃ¼tÃ¼phane gerekebilir (Ã¶rn: newspaper3k, beautifulsoup4)
                    # Åimdilik basit bir baÅŸlÄ±k + aÃ§Ä±klama dÃ¶nelim
                    text_content = f"Title: {title.strip()}\nDescription: {description.strip()}"
                    return {"text": text_content, "image_url": image_url}
                elif content_type.startswith("image/"):
                    image_bytes = await response.read()
                    return {"image_bytes": image_bytes, "mime_type": content_type}
                # DiÄŸer iÃ§erik tÃ¼rleri iÃ§in de geniÅŸletilebilir (JSON, TXT vb.)
    except asyncio.TimeoutError:
        logger.warning(f"URL getirme zaman aÅŸÄ±mÄ±: {url}")
    except Exception as e:
        logger.error(f"URL iÃ§eriÄŸi alÄ±nÄ±rken hata ({url}): {e}")
    return None

async def extract_text_from_pdf_bytes(pdf_bytes: bytes, user_id: int) -> str | None:
    if PdfReader is None:
        logger.error("PDF iÅŸleme iÃ§in pypdf2 kÃ¼tÃ¼phanesi kurulu deÄŸil.")
        return get_lang_string(user_id, "error_pdf_library_missing")
    try:
        reader = PdfReader(BytesIO(pdf_bytes))
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"
        return text.strip()
    except Exception as e:
        logger.error(f"PDF'ten metin Ã§Ä±karÄ±lÄ±rken hata: {e}")
        return None # Hata durumunda None dÃ¶n, komut iÃ§inde kullanÄ±cÄ±ya mesaj verilsin

async def process_message_for_ai_input(message: discord.Message, user_id_for_lang: int) -> tuple[list, str | None]:
    """
    Bir mesajÄ± (ve yanÄ±tladÄ±ÄŸÄ± mesajÄ±) iÅŸleyerek AI'a gÃ¶nderilecek metin ve gÃ¶rsel parÃ§alarÄ±nÄ± Ã§Ä±karÄ±r.
    Returns: tuple (prompt_parts_list, error_message_key_or_None)
    prompt_parts_list: String ve PIL.Image objeleri iÃ§erebilir.
    """
    prompt_parts = []
    attachments_processed_for_multimodal = False
    MAX_FILE_SIZE_MB = 8 # Gemini iÃ§in daha bÃ¼yÃ¼k olabilir, gÃ¼venli bir limit
    MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024

    async def process_single_message_content(msg_obj: discord.Message):
        nonlocal attachments_processed_for_multimodal
        # 1. MesajÄ±n kendi metni
        if msg_obj.content:
            # Linkleri iÅŸle
            url_pattern = r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+"
            urls_found = re.findall(url_pattern, msg_obj.content)
            processed_content = msg_obj.content

            async with aiohttp.ClientSession() as session:
                for url in urls_found:
                    logger.info(f"Ä°ÅŸleniyor URL: {url}")
                    url_data = await fetch_url_content(session, url)
                    if url_data:
                        if "text" in url_data:
                            prompt_parts.append(f"\n--- Link Content ({url}) ---\n{url_data['text']}\n--- End Link Content ---")
                        if "image_url" in url_data and url_data["image_url"]:
                            # Linkten gelen resmi de indirip AI'a gÃ¶nderme
                            img_link_data = await fetch_url_content(session, url_data["image_url"])
                            if img_link_data and "image_bytes" in img_link_data:
                                try:
                                    pil_image = Image.open(BytesIO(img_link_data["image_bytes"]))
                                    prompt_parts.append(pil_image)
                                    attachments_processed_for_multimodal = True
                                except Exception as e_pil:
                                    logger.error(f"URL'den gelen resim PIL'e Ã§evrilirken hata: {e_pil}")
                        elif "image_bytes" in url_data: # DoÄŸrudan resim linki ise
                             try:
                                pil_image = Image.open(BytesIO(url_data["image_bytes"]))
                                prompt_parts.append(pil_image)
                                attachments_processed_for_multimodal = True
                             except Exception as e_pil:
                                logger.error(f"DoÄŸrudan resim linki PIL'e Ã§evrilirken hata: {e_pil}")
                    # Ä°ÅŸlenmiÅŸ linki metinden Ã§Ä±karmak yerine olduÄŸu gibi bÄ±rakabiliriz, AI'Ä±n baÄŸlamÄ± anlamasÄ±na yardÄ±mcÄ± olur.
                    # processed_content = processed_content.replace(url, f"[{url_data['text'][:50]}... (link)]" if url_data and 'text' in url_data else f"[{url} (link)]")
            
            if processed_content.strip():
                 prompt_parts.append(processed_content.strip())


        # 2. Embed'ler
        for embed in msg_obj.embeds:
            embed_text_parts = []
            if embed.title: embed_text_parts.append(f"Embed Title: {embed.title}")
            if embed.description: embed_text_parts.append(f"Embed Description: {embed.description}")
            for field in embed.fields:
                embed_text_parts.append(f"Embed Field ({field.name}): {field.value}")
            if embed.footer and embed.footer.text: embed_text_parts.append(f"Embed Footer: {embed.footer.text}")
            if embed.author and embed.author.name: embed_text_parts.append(f"Embed Author: {embed.author.name}")
            
            if embed_text_parts:
                prompt_parts.append(f"\n--- Embed Content ---\n" + "\n".join(embed_text_parts) + "\n--- End Embed Content ---")

            if embed.image and embed.image.url:
                try:
                    async with aiohttp.ClientSession() as session, session.get(embed.image.url) as resp:
                        if resp.status == 200 and resp.content_length < MAX_FILE_SIZE_BYTES:
                            image_bytes = await resp.read()
                            pil_image = Image.open(BytesIO(image_bytes))
                            prompt_parts.append(pil_image)
                            attachments_processed_for_multimodal = True
                        elif resp.content_length >= MAX_FILE_SIZE_BYTES:
                             logger.warning(f"Embed resmi Ã§ok bÃ¼yÃ¼k: {embed.image.url}")
                             prompt_parts.append(f"[Embed Image (Too Large): {embed.image.url}]")
                except Exception as e:
                    logger.error(f"Embed resmi iÅŸlenirken hata ({embed.image.url}): {e}")
                    prompt_parts.append(f"[Embed Image (Error): {embed.image.url}]")
            
            if embed.thumbnail and embed.thumbnail.url: # Thumbnail'Ä± da benzer ÅŸekilde iÅŸle
                try:
                    async with aiohttp.ClientSession() as session, session.get(embed.thumbnail.url) as resp:
                        if resp.status == 200 and resp.content_length < MAX_FILE_SIZE_BYTES:
                            image_bytes = await resp.read()
                            pil_image = Image.open(BytesIO(image_bytes))
                            prompt_parts.append(pil_image)
                            attachments_processed_for_multimodal = True
                        elif resp.content_length >= MAX_FILE_SIZE_BYTES:
                             logger.warning(f"Embed thumbnail resmi Ã§ok bÃ¼yÃ¼k: {embed.thumbnail.url}")
                             prompt_parts.append(f"[Embed Thumbnail (Too Large): {embed.thumbnail.url}]")
                except Exception as e:
                    logger.error(f"Embed thumbnail resmi iÅŸlenirken hata ({embed.thumbnail.url}): {e}")
                    prompt_parts.append(f"[Embed Thumbnail (Error): {embed.thumbnail.url}]")


        # 3. Ekler (Attachments)
        for attachment in msg_obj.attachments:
            if attachment.size > MAX_FILE_SIZE_BYTES:
                logger.warning(f"Ek Ã§ok bÃ¼yÃ¼k: {attachment.filename} ({attachment.size} bytes)")
                prompt_parts.append(f"[{attachment.filename} (File Too Large)]")
                continue

            content_type = attachment.content_type.lower() if attachment.content_type else ""
            
            if content_type.startswith("image/"):
                try:
                    image_bytes = await attachment.read()
                    pil_image = Image.open(BytesIO(image_bytes))
                    prompt_parts.append(pil_image)
                    attachments_processed_for_multimodal = True
                except Exception as e:
                    logger.error(f"GÃ¶rsel eki iÅŸlenirken hata ({attachment.filename}): {e}")
                    prompt_parts.append(f"[{attachment.filename} (Image Error)]")
            elif content_type == "application/pdf" and PdfReader:
                try:
                    pdf_bytes = await attachment.read()
                    pdf_text = await extract_text_from_pdf_bytes(pdf_bytes, user_id_for_lang)
                    if pdf_text:
                        prompt_parts.append(f"\n--- PDF Content ({attachment.filename}) ---\n{pdf_text[:3000]}...\n--- End PDF Content ---") # Limitle
                    else:
                        prompt_parts.append(f"[{attachment.filename} (Could not extract text from PDF)]")
                except Exception as e:
                    logger.error(f"PDF eki iÅŸlenirken hata ({attachment.filename}): {e}")
                    prompt_parts.append(f"[{attachment.filename} (PDF Error)]")
            elif content_type.startswith("text/plain"):
                try:
                    text_bytes = await attachment.read()
                    text_content = text_bytes.decode("utf-8", errors="ignore") # En yaygÄ±n encoding
                    prompt_parts.append(f"\n--- TXT Content ({attachment.filename}) ---\n{text_content[:3000]}...\n--- End TXT Content ---") # Limitle
                except Exception as e:
                    logger.error(f"TXT eki iÅŸlenirken hata ({attachment.filename}): {e}")
                    prompt_parts.append(f"[{attachment.filename} (TXT Error)]")
            elif content_type.startswith("video/") or content_type.startswith("audio/"):
                 prompt_parts.append(f"[Attachment: {attachment.filename} (Video/Audio - Content not directly processed, URL: {attachment.url})]")
            elif attachment.url: # DiÄŸer dosya tÃ¼rleri iÃ§in linkini ekle
                 prompt_parts.append(f"[Attachment: {attachment.filename} (URL: {attachment.url})]")


        # 4. Ã‡Ä±kartmalar (Stickers)
        for sticker_item in msg_obj.stickers:
            sticker_text = f"Sticker: {sticker_item.name}"
            if sticker_item.format == discord.StickerFormatType.png or sticker_item.format == discord.StickerFormatType.apng:
                try:
                    async with aiohttp.ClientSession() as session, session.get(sticker_item.url) as resp:
                        if resp.status == 200 and resp.content_length < MAX_FILE_SIZE_BYTES:
                            image_bytes = await resp.read()
                            pil_image = Image.open(BytesIO(image_bytes))
                            prompt_parts.append(pil_image)
                            attachments_processed_for_multimodal = True
                            sticker_text += " (Image processed)"
                        else:
                             sticker_text += f" (Image too large or unavailable: {sticker_item.url})"
                except Exception as e:
                    logger.error(f"Ã‡Ä±kartma resmi iÅŸlenirken hata ({sticker_item.name}): {e}")
                    sticker_text += f" (Image error: {sticker_item.url})"
            elif sticker_item.format == discord.StickerFormatType.lottie and sticker_item.url: # Lottie iÃ§in sadece bilgi
                sticker_text += f" (Lottie animation - Content not directly processed, URL: {sticker_item.url})"
            prompt_parts.append(f"\n--- Sticker Item ---\n{sticker_text}\n--- End Sticker Item ---")


    # Ana mesajÄ± iÅŸle
    await process_single_message_content(message)

    # EÄŸer bir mesaja yanÄ±t veriyorsa, o mesajÄ± da iÅŸle
    if message.reference and message.reference.message_id:
        try:
            replied_to_message = await message.channel.fetch_message(message.reference.message_id)
            if replied_to_message:
                prompt_parts.append("\n--- Replying to Content ---")
                await process_single_message_content(replied_to_message)
                prompt_parts.append("--- End Replying to Content ---")
        except discord.NotFound:
            logger.warning(f"YanÄ±tlanan mesaj ({message.reference.message_id}) bulunamadÄ±.")
        except Exception as e_ref_proc:
            logger.error(f"YanÄ±tlanan mesaj iÅŸlenirken hata: {e_ref_proc}")

    # Prompt parÃ§alarÄ±nÄ± temizle (boÅŸ stringleri kaldÄ±r)
    cleaned_prompt_parts = [part for part in prompt_parts if (isinstance(part, str) and part.strip()) or isinstance(part, Image.Image)]
    
    return cleaned_prompt_parts, None # Åimdilik hata mesajÄ± yok

# --- Kredi ve ZamanlayÄ±cÄ± FonksiyonlarÄ± ---
async def grant_credits_if_needed(user_id: int, amount: int, reason: str):
    """ Belirli bir sebeple kredi verir ve kullanÄ±cÄ±yÄ± bilgilendirir. """
    udata = get_user_data_entry(user_id)
    udata["credits"] += amount
    save_json_data(USER_DATA_FILE, user_data)
    logger.info(f"{amount} kredi verildi. KullanÄ±cÄ±: {user_id}, Sebep: {reason}, Yeni Bakiye: {udata['credits']}")
    
    # KullanÄ±cÄ±ya DM ile veya komut kanalÄ±nda bilgi verilebilir. Åimdilik log yeterli.
    # try:
    #     user_obj = await client.fetch_user(user_id)
    #     if user_obj:
    #         lang_msg = get_lang_string(user_id, "credits_granted_generic_dm", amount=amount, reason=reason, new_balance=udata['credits'])
    #         await user_obj.send(lang_msg)
    # except Exception as e:
    #     logger.warning(f"Kredi verildi DM gÃ¶nderilemedi ({user_id}): {e}")


async def daily_credit_handler():
    await client.wait_until_ready()
    while not client.is_closed():
        now = datetime.now(timezone.utc)
        for user_id_str, u_data in list(user_data.items()): # list() ile kopyala, iterasyon sÄ±rasÄ±nda deÄŸiÅŸiklik yapÄ±labilir
            user_id = int(user_id_str)
            last_daily_ts_str = u_data.get("last_daily_credit_timestamp")
            grant_daily = False
            if last_daily_ts_str:
                try:
                    last_daily_ts = datetime.fromisoformat(last_daily_ts_str)
                    if now - last_daily_ts >= timedelta(hours=23, minutes=50): # Neredeyse 24 saat
                        grant_daily = True
                except ValueError:
                    grant_daily = True # GeÃ§ersiz zaman damgasÄ±, yine de ver
            else:
                grant_daily = True # Ä°lk defa alÄ±yor

            if grant_daily:
                current_credits = u_data.get("credits", 0)
                u_data["credits"] = current_credits + 10
                u_data["last_daily_credit_timestamp"] = now.isoformat()
                logger.info(f"KullanÄ±cÄ± {user_id_str} iÃ§in 10 gÃ¼nlÃ¼k kredi verildi. Yeni bakiye: {u_data['credits']}")
                # KullanÄ±cÄ±ya DM veya bir log kanalÄ± aracÄ±lÄ±ÄŸÄ±yla bilgi verilebilir.
                # Åimdilik save_json_data yeterli.
        
        save_json_data(USER_DATA_FILE, user_data) # Her dÃ¶ngÃ¼de bir kez kaydet
        await asyncio.sleep(60 * 30) # Her 30 dakikada bir kontrol et

async def check_and_deduct_credits(interaction_or_message: Interaction | Message, command_name: str):
    """
    KullanÄ±cÄ±nÄ±n kredisi olup olmadÄ±ÄŸÄ±nÄ± kontrol eder, varsa 1 dÃ¼ÅŸer.
    Returns: True (baÅŸarÄ±lÄ± ve kredi dÃ¼ÅŸÃ¼ldÃ¼), False (yetersiz kredi veya premium).
             None (AI komutu deÄŸil veya hata).
    """
    user = interaction_or_message.author if isinstance(interaction_or_message, Message) else interaction_or_message.user
    if is_premium_user(user.id):
        return True # Premium kullanÄ±cÄ±lar kredi harcamaz

    udata = get_user_data_entry(user.id)
    if udata["credits"] > 0:
        udata["credits"] -= 1
        save_json_data(USER_DATA_FILE, user_data)
        # KullanÄ±cÄ±ya bilgi mesajÄ± (isteÄŸe baÄŸlÄ±, Ã§ok sÄ±k olursa spam olabilir)
        # try:
        #     cost_msg = get_lang_string(user.id, "command_cost_message", user_credits=udata['credits'])
        #     if isinstance(interaction_or_message, Interaction):
        #         await interaction_or_message.followup.send(cost_msg, ephemeral=True)
        #     else:
        #         await interaction_or_message.channel.send(f"{user.mention}, {cost_msg}", delete_after=10)
        # except: pass
        return True
    else:
        # Kredi bitti mesajÄ±
        exhausted_msg = get_lang_string(user.id, "credits_exhausted_message")
        if isinstance(interaction_or_message, Interaction):
            if not interaction_or_message.response.is_done():
                await interaction_or_message.response.send_message(exhausted_msg, ephemeral=True)
            else:
                await interaction_or_message.followup.send(exhausted_msg, ephemeral=True)
        else: # Message objesi ise
            await interaction_or_message.reply(exhausted_msg, mention_author=False)
        return False


# --- Bot HazÄ±r OlduÄŸunda ---
@client.event
async def on_ready():
    global user_data, premium_users, language_strings, guild_personalities
    logger.info(f'{BOT_NAME} ({client.user}) ({VERSION}) gÃ¶reve hazÄ±r!')

    # Veri dosyalarÄ±nÄ± yÃ¼kle
    user_data = load_json_data(USER_DATA_FILE, {})
    premium_users = load_json_data(PREMIUM_DATA_FILE, {}) # Premium kullanÄ±cÄ± ID'lerini string olarak saklar
    guild_personalities = load_json_data(GUILD_PERSONALITIES_FILE, {})
    load_translations() # Dil stringlerini yÃ¼kle

    # KullanÄ±lmayan kullanÄ±cÄ±larÄ± user_data'dan temizle (isteÄŸe baÄŸlÄ±, performansÄ± etkileyebilir)
    # active_user_ids = set() # ... sunuculardaki Ã¼yelerden topla ...
    # for uid_str in list(user_data.keys()):
    #     if uid_str not in active_user_ids:
    #         del user_data[uid_str]
    # save_json_data(USER_DATA_FILE, user_data)

    try:
        synced_commands = await tree.sync()
        logger.info(f"{len(synced_commands)} adet slash komutu senkronize edildi.")
        for cmd in synced_commands:
            logger.info(f"  -> Synced: /{cmd.name}")
    except Exception as e:
        logger.error(f"Slash komut senkronizasyon hatasÄ±: {e}")

    await client.change_presence(activity=discord.Game(name=f"/help | {PREFIX}help"))

    # GÃ¼nlÃ¼k kredi verme gÃ¶revini baÅŸlat
    client.loop.create_task(daily_credit_handler())

    # FastAPI'yi arka planda Ã§alÄ±ÅŸtÄ±r
    def run_fastapi():
        uvicorn.run(fastapi_app, host="0.0.0.0", port=int(os.environ.get("PORT", 8000)), log_level="warning")
    threading.Thread(target=run_fastapi, daemon=True).start()
    logger.info("FastAPI web sunucusu arka planda baÅŸlatÄ±ldÄ±.")

# --- Ana Mesaj Ä°ÅŸleyici (on_message) ---
@client.event
async def on_message(message: Message):
    if message.author.bot or not message.guild:
        return # Bot mesajlarÄ±nÄ± ve DM'leri ÅŸimdilik yoksay (DM'ler iÃ§in ayrÄ± mantÄ±k eklenebilir)

    user_id = message.author.id
    user_lang = get_user_data_entry(user_id).get("language", "en")

    # 1. Bota DoÄŸrudan Mention ile Sohbet
    if client.user.mentioned_in(message) and not message.mention_everyone:
        # Kendi komut yanÄ±tÄ±na reply ise ve tekrar mention yoksa iÅŸlem yapma
        if message.reference:
            try:
                replied_to = await message.channel.fetch_message(message.reference.message_id)
                if replied_to.author == client.user:
                    # EÄŸer botun bir komut yanÄ±tÄ±na (veya genel bir mesajÄ±na) reply atÄ±lÄ±yorsa
                    # ve kullanÄ±cÄ± tekrar botu mentionlamÄ±yorsa (sadece reply ise) bu bir sohbet devamÄ± sayÄ±lmaz.
                    # Ancak, kullanÄ±cÄ± botun yanÄ±tÄ±na reply atÄ±p aynÄ± zamanda botu tekrar mention'larsa, bu sohbet devamÄ± sayÄ±lÄ±r.
                    # Bu kontrol, "bot kendi komut yanÄ±tÄ±na reply atarsa cevap vermesin" mantÄ±ÄŸÄ±nÄ± da kapsar.
                    # EÄŸer "bot hiÃ§ bir komutta tekrar yanÄ±t vermesin" daha katÄ±ysa, o zaman bu if'i daha da sÄ±kÄ±laÅŸtÄ±rmak gerekir.
                    # Mevcut durumda, eÄŸer kullanÄ±cÄ± botun mesajÄ±na reply atÄ±p @OmniVerseAI diye tekrar etiketlerse sohbet devam eder.
                    # Sadece reply atarsa ve botun Ã¶nceki mesajÄ± bir komut yanÄ±tÄ± deÄŸilse (yani saf AI sohbetiyse) o zaman da devam eder.
                    # Bu kÄ±sÄ±m biraz karmaÅŸÄ±k, kullanÄ±cÄ± isteÄŸine gÃ¶re ayarlanacak.
                    # Åimdilik: EÄŸer botun mesajÄ±na reply atÄ±lÄ±yor VE tekrar mention yoksa, normal prefix komutlarÄ±na geÃ§.
                    # EÄŸer botun mesajÄ±na reply atÄ±lÄ±yor VE tekrar mention VARSA, bu bir AI sohbet devamÄ±dÄ±r.
                    is_reply_to_bot_without_new_mention = (replied_to.author == client.user and not re.search(rf"<@!?{client.user.id}>", message.content))
                    if is_reply_to_bot_without_new_mention:
                        # Normal prefix komutlarÄ±nÄ± iÅŸlemesi iÃ§in aÅŸaÄŸÄ±ya dÃ¼ÅŸmesine izin ver
                        pass # Bu if'i atlayÄ±p prefix kontrolÃ¼ne geÃ§
                    else: # Ya yeni mention var ya da botun olmayan bir mesaja reply (bu durumda da AI sohbeti olabilir)
                        # AI sohbeti devam edebilir.
                        pass # Devam eden AI sohbeti iÃ§in aÅŸaÄŸÄ±ya akacak
            except discord.NotFound:
                pass # YanÄ±tlanan mesaj bulunamadÄ±, yeni sohbet gibi davranÄ±labilir

        if not await check_and_deduct_credits(message, "ai_chat"):
            return # Kredi yoksa veya bitti mesajÄ± gÃ¶nderildiyse Ã§Ä±k

        thinking_msg_key = "ai_thinking"
        #thinking_message_content = get_lang_string(user_id, thinking_msg_key)
        # if not is_premium_user(user_id): # Ãœcretsiz kullanÄ±cÄ±ya gecikme bilgisini ekle
        #     thinking_message_content += " " + get_lang_string(user_id, "ai_response_delayed_free", delay_seconds=3.5)
        
        # thinking_discord_msg = await message.reply(thinking_message_content, mention_author=False)
        async with message.channel.typing(): # Typing gÃ¶stergesi daha iyi
            # Mevcut mesajdan ve yanÄ±tladÄ±ÄŸÄ± mesajdan AI iÃ§in inputlarÄ± Ã§Ä±kar
            ai_prompt_parts, error_msg_key = await process_message_for_ai_input(message, user_id)
            
            if error_msg_key:
                # await thinking_discord_msg.delete()
                await message.reply(get_lang_string(user_id, error_msg_key), mention_author=False)
                return

            if not ai_prompt_parts:
                # await thinking_discord_msg.delete()
                await message.reply(get_lang_string(user_id, "error_ai_no_content_to_process"), mention_author=False)
                return
            
            # KiÅŸilik ayarlarÄ±nÄ± kontrol et (sadece doÄŸrudan mention sohbetleri iÃ§in)
            guild_pers_data = get_guild_personality(message.guild.id)
            apply_guild_pers = False
            if guild_pers_data and guild_pers_data.get("active", False):
                apply_guild_pers = True

            ai_response = await ask_gemini_core(
                ai_prompt_parts,
                user_id=user_id,
                target_language_code=user_lang,
                apply_guild_chat_personality=apply_guild_pers,
                guild_id=message.guild.id
            )

        # try: await thinking_discord_msg.delete()
        # except discord.NotFound: pass

        if ai_response:
            # YanÄ±tÄ± 2000 karakterlik parÃ§alara bÃ¶l
            for chunk in [ai_response[i:i + 1990] for i in range(0, len(ai_response), 1990)]:
                await message.reply(chunk, mention_author=False)
        else: # ask_gemini_core zaten hata mesajÄ± dÃ¶ndÃ¼rmeli
            await message.reply(get_lang_string(user_id, "error_ai_failed_to_respond"), mention_author=False)
        return # Mention ile iÅŸlendi, prefix komutlarÄ±nÄ± kontrol etme


    # 2. Prefix KomutlarÄ±
    if message.content.startswith(PREFIX):
        # Komut yanÄ±tÄ±na reply ise iÅŸlem yapma (yukarÄ±daki mention mantÄ±ÄŸÄ± bunu zaten bir Ã¶lÃ§Ã¼de engelliyor)
        if message.reference:
            try:
                replied_to_prefix_check = await message.channel.fetch_message(message.reference.message_id)
                if replied_to_prefix_check.author == client.user:
                    # EÄŸer botun bir mesajÄ±na (Ã¶zellikle komut yanÄ±tÄ±na) sadece prefix ile yanÄ±t veriliyorsa, bunu engelle.
                    # Bu, "bot hiÃ§bir komutta tekrar yanÄ±t vermesin" kuralÄ±nÄ± destekler.
                    is_command_response = False # Botun Ã¶nceki mesajÄ±nÄ±n bir komut yanÄ±tÄ± olup olmadÄ±ÄŸÄ±nÄ± anlamak zor.
                                                # Åimdilik, botun herhangi bir mesajÄ±na prefix ile reply atÄ±lÄ±rsa iÅŸlem yapma.
                    logger.debug(f"Prefix komutu botun mesajÄ±na yanÄ±t olarak geldi, iÅŸlenmiyor: {message.content}")
                    return
            except discord.NotFound:
                pass # Sorun yok, devam et.

        # KomutlarÄ± iÅŸle (buraya prefix tabanlÄ± komutlarÄ±n mantÄ±ÄŸÄ± gelecek)
        # Ã–rneÄŸin:
        # args = message.content[len(PREFIX):].strip().split()
        # command = args.pop(0).lower()
        # await handle_prefix_command(message, command, args) # Bu helper fonksiyonu tanÄ±mlamanÄ±z gerekir
        
        # GeÃ§ici olarak, prefix komutlarÄ±nÄ±n slash komutlarÄ±na yÃ¶nlendirildiÄŸini belirten bir mesaj:
        logger.info(f"Prefix komutu algÄ±landÄ±: {message.content}. KullanÄ±cÄ±ya slash komutu kullanmasÄ± Ã¶nerilecek.")
        # await message.reply(
        #     f"Hey {message.author.mention}! Prefix komutlarÄ± yerine artÄ±k daha modern slash komutlarÄ±nÄ± (`/`) kullanÄ±yoruz. "
        #     f"LÃ¼tfen `/help` yazarak mevcut komutlarÄ± incele.",
        #     mention_author=False,
        #     delete_after=20
        # )
        # AslÄ±nda, prefix komutlarÄ± da slash komutlarÄ±yla aynÄ± iÅŸlevi gÃ¶rmeli.
        # Bu yÃ¼zden, her slash komutu iÃ§in bir prefix aliasÄ± da oluÅŸturacaÄŸÄ±z.
        # Bu, `on_message` iÃ§inde bir komut yÃ¶nlendirici (router) gerektirir.
        # Åimdilik bu kÄ±smÄ± basit tutuyorum, sadece logluyorum.
        # Ä°stek: "tÃ¼m komutlar hem / hem . ile Ã§alÄ±ÅŸsÄ±n"
        # Bu, her slash komutunun bir de prefix versiyonunun tanÄ±mlanmasÄ± gerektiÄŸi anlamÄ±na gelir.
        # Veya on_message iÃ§inde manuel bir dispatching mekanizmasÄ±.

        # Ã–rnek prefix komut iÅŸleyici (her komut iÃ§in ayrÄ± if/elif bloÄŸu)
        full_command_str = message.content[len(PREFIX):].strip()
        if not full_command_str: return
        
        command_parts = full_command_str.split()
        command_name_prefix = command_parts[0].lower()
        command_args_prefix = command_parts[1:]

        # KomutlarÄ± manuel olarak yÃ¶nlendirelim
        # Bu kÄ±sÄ±m, her slash komutu iÃ§in bir prefix karÅŸÄ±lÄ±ÄŸÄ± gerektirecek ve Ã§ok uzayacak.
        # Daha iyi bir yol, slash komut objelerini bir yerde saklayÄ±p, isimle eÅŸleÅŸtirip Ã§aÄŸÄ±rmak olabilir.
        # Åimdilik sadece birkaÃ§ Ã¶rnek:
        if command_name_prefix == "ping":
            await message.reply(f"Pong! {round(client.latency * 1000)}ms", mention_author=False)
        elif command_name_prefix == "summarize":
            # Buraya /summarize komutunun mantÄ±ÄŸÄ±nÄ± Ã§aÄŸÄ±ran bir yapÄ± gelecek
            # Bu, slash komut fonksiyonunu doÄŸrudan Ã§aÄŸÄ±rmak veya ortak bir iÅŸlev kullanmak anlamÄ±na gelir.
            # Åimdilik placeholder:
            await message.reply(f"Prefix `{command_name_prefix}` komutu algÄ±landÄ±. Bunun iÃ§in slash komutunu kullanÄ±n.", mention_author=False)
        # ... diÄŸer prefix komutlarÄ± ...
        return # Prefix komutu iÅŸlendi veya yÃ¶nlendirildi.

# --- Slash KomutlarÄ± ---

# YardÄ±mcÄ± Fonksiyon: Interaction'dan dil kodunu al
def get_user_lang_from_interaction(interaction: Interaction) -> str:
    return get_user_data_entry(interaction.user.id).get("language", "en")

# Komut: /ping
@tree.command(name="ping", description="Shows the bot's latency.")
async def ping_slash(interaction: Interaction):
    user_lang = get_user_lang_from_interaction(interaction) # Ã–rnek dil kullanÄ±mÄ±
    await interaction.response.send_message(f"Pong! {EMOJIS['success']} Latency: {round(client.latency * 1000)}ms")


# Komut: /premium
@tree.command(name="premium", description="Information about OmniVerse AI Premium.")
async def premium_slash(interaction: Interaction):
    user_lang = get_user_lang_from_interaction(interaction)
    embed = Embed(
        title=get_lang_string(user_id=interaction.user.id, key="premium_command_title"),
        description=get_lang_string(user_id=interaction.user.id, key="premium_command_description"),
        color=discord.Color.gold() # Premium rengi
    )
    if client.user.avatar:
        embed.set_thumbnail(url=client.user.avatar.url)
    embed.add_field(
        name=EMOJIS['link'] + " " + get_lang_string(user_id=interaction.user.id, key="premium_command_link_text"),
        value="[Your Premium Purchase Link Here - e.g., Patreon, Ko-fi]", # GERÃ‡EK LÄ°NKÄ°NÄ°ZÄ° BURAYA EKLEYÄ°N
        inline=False
    )
    embed.set_footer(text=f"{BOT_NAME} v{VERSION}")
    await interaction.response.send_message(embed=embed, ephemeral=True)


# Komut: /language
class LanguageSelect(ui.Select):
    def __init__(self, user_id_for_lang_strings: int):
        self.user_id_for_lang_strings = user_id_for_lang_strings
        options = [
            discord.SelectOption(label=lang_data["name"], value=lang_code, emoji=lang_data["flag"])
            for lang_code, lang_data in SUPPORTED_LANGUAGES.items()
        ]
        super().__init__(placeholder=get_lang_string(user_id_for_lang_strings, "select_language_placeholder", default="Choose your language..."), min_values=1, max_values=1, options=options)

    async def callback(self, interaction: Interaction):
        selected_lang_code = self.values[0]
        udata = get_user_data_entry(interaction.user.id)
        udata["language"] = selected_lang_code
        save_json_data(USER_DATA_FILE, user_data)
        
        lang_name_display = SUPPORTED_LANGUAGES.get(selected_lang_code, {}).get("name", selected_lang_code)
        await interaction.response.send_message(
            get_lang_string(interaction.user.id, "language_set", language_name=lang_name_display),
            ephemeral=True
        )
        # MenÃ¼yÃ¼ kaldÄ±r
        await interaction.edit_original_response(view=None)


class LanguageView(ui.View):
    def __init__(self, user_id_for_lang_strings: int, original_interaction_user_id: int):
        super().__init__(timeout=180.0)
        self.original_interaction_user_id = original_interaction_user_id
        self.add_item(LanguageSelect(user_id_for_lang_strings))

    async def interaction_check(self, interaction: Interaction) -> bool:
        # Sadece komutu baÅŸlatan kiÅŸi etkileÅŸimde bulunabilir
        if interaction.user.id != self.original_interaction_user_id:
            await interaction.response.send_message(
                get_lang_string(interaction.user.id, "error_not_your_interaction", default="This is not for you!"),
                ephemeral=True
            )
            return False
        return True
    
    async def on_timeout(self):
        # Zaman aÅŸÄ±mÄ±nda mesajdan view'Ä± kaldÄ±r (eÄŸer mesaj hala varsa)
        if self.message:
            try:
                await self.message.edit(view=None)
            except discord.NotFound:
                pass # Mesaj silinmiÅŸ olabilir
            except Exception as e:
                logger.warning(f"LanguageView on_timeout mesaj dÃ¼zenleme hatasÄ±: {e}")
        self.stop()

@tree.command(
    name="language",
    description="Set your preferred language for bot responses.",
    description_localizations=get_all_localized_descriptions("language") # YerelleÅŸtirilmiÅŸ aÃ§Ä±klamalar
)
async def language_slash(interaction: Interaction):
    user_lang = get_user_lang_from_interaction(interaction) # Mevcut dil ayarÄ±nÄ± al
    view = LanguageView(user_id_for_lang_strings=interaction.user.id, original_interaction_user_id=interaction.user.id)
    
    embed_desc = get_lang_string(interaction.user.id, "language_selection_embed_description", default="Please select your preferred language from the menu below. This will change the language of my responses to you.")
    current_lang_name = SUPPORTED_LANGUAGES.get(user_lang, {}).get("name", user_lang)
    embed_desc += f"\n\nYour current language is: **{current_lang_name}** {SUPPORTED_LANGUAGES.get(user_lang, {}).get('flag', '')}"

    embed = Embed(
        title=f"{EMOJIS['translate']} Language Selection",
        description=embed_desc,
        color=discord.Color.blue()
    )
    await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
    view.message = await interaction.original_response() # MesajÄ± sakla ki timeout'ta dÃ¼zenlenebilsin


# Komut: /editpersonality
@tree.command(
    name="editpersonality",
    description="Edit the AI's personality for direct mentions in this server.",
    description_localizations=get_all_localized_descriptions("editpersonality")
)
@app_commands.describe(
    action="Enable, disable, or view the current personality.",
    prompt="The personality prompt for the AI (if enabling/editing)."
)
@app_commands.choices(action=[
    app_commands.Choice(name="Enable/Edit", value="enable"),
    app_commands.Choice(name="Disable", value="disable"),
    app_commands.Choice(name="View", value="view"),
])
@app_commands.checks.has_permissions(manage_guild=True) # Sadece sunucu yÃ¶neticileri
async def editpersonality_slash(interaction: Interaction, action: str, prompt: str = None):
    if not interaction.guild_id:
        await interaction.response.send_message(get_lang_string(interaction.user.id, "error_guild_only_command", default="This command can only be used in a server."), ephemeral=True)
        return

    guild_id_str = str(interaction.guild_id)
    current_personality = guild_personalities.get(guild_id_str, {"prompt": None, "active": False})

    if action == "enable":
        if not prompt or len(prompt) < 10:
            await interaction.response.send_message(get_lang_string(interaction.user.id, "error_personality_prompt_too_short", default="Personality prompt must be at least 10 characters."), ephemeral=True)
            return
        if len(prompt) > 1500: # Makul bir limit
            await interaction.response.send_message(get_lang_string(interaction.user.id, "error_personality_prompt_too_long", max_chars=1500, default="Personality prompt cannot exceed 1500 characters."), ephemeral=True)
            return
        
        guild_personalities[guild_id_str] = {"prompt": prompt, "active": True}
        save_json_data(GUILD_PERSONALITIES_FILE, guild_personalities)
        logger.info(f"Guild {guild_id_str} personality enabled/updated by {interaction.user.id}. Prompt: {prompt[:50]}...")
        await interaction.response.send_message(get_lang_string(interaction.user.id, "personality_set_success"), ephemeral=True)

    elif action == "disable":
        if current_personality["active"]:
            guild_personalities[guild_id_str] = {"prompt": current_personality["prompt"], "active": False} # Prompt'u sakla ama deaktif et
            save_json_data(GUILD_PERSONALITIES_FILE, guild_personalities)
            logger.info(f"Guild {guild_id_str} personality disabled by {interaction.user.id}.")
            await interaction.response.send_message(get_lang_string(interaction.user.id, "personality_disabled_success"), ephemeral=True)
        else:
            await interaction.response.send_message(get_lang_string(interaction.user.id, "personality_no_active"), ephemeral=True)
            
    elif action == "view":
        if current_personality["active"] and current_personality["prompt"]:
            embed = Embed(title=get_lang_string(interaction.user.id, "personality_view_title", default="Current Server AI Personality (for Mentions)"),
                          description=f"```\n{current_personality['prompt']}\n```\nStatus: **Active**",
                          color=discord.Color.purple())
            await interaction.response.send_message(embed=embed, ephemeral=True)
        elif current_personality["prompt"]: # Aktif deÄŸil ama prompt var
             embed = Embed(title=get_lang_string(interaction.user.id, "personality_view_title_inactive", default="Stored Server AI Personality (Currently Inactive)"),
                          description=f"```\n{current_personality['prompt']}\n```\nStatus: **Inactive**",
                          color=discord.Color.orange())
             await interaction.response.send_message(embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message(get_lang_string(interaction.user.id, "personality_no_active"), ephemeral=True)


# --- AI KomutlarÄ± ---
async def handle_ai_command_interaction(
    interaction: Interaction,
    command_name_log: str, # Loglama iÃ§in
    prompt_parts_for_ai: list,
    is_multimodal_capable_command: bool = True # Ã‡oÄŸu AI komutu multimodal olabilir
):
    """ Genel AI komutlarÄ± iÃ§in temel iÅŸleyici (kredi, AI Ã§aÄŸrÄ±sÄ±, yanÄ±t) """
    user_id = interaction.user.id
    user_lang = get_user_lang_from_interaction(interaction)

    if not await check_and_deduct_credits(interaction, command_name_log):
        return # Kredi yok veya bitti mesajÄ± zaten gÃ¶nderildi

    await interaction.response.defer(ephemeral=False) # Komutlar genelde public yanÄ±t verir

    thinking_msg_key = "ai_thinking"
    thinking_message_content = get_lang_string(user_id, thinking_msg_key)
    if not is_premium_user(user_id):
        thinking_message_content += " " + get_lang_string(user_id, "ai_response_delayed_free", delay_seconds=3.5) # Gecikme bilgisi
    
    # GeÃ§ici "dÃ¼ÅŸÃ¼nÃ¼yor" mesajÄ± gÃ¶ndermek yerine defer() yeterli olabilir, Discord kendisi gÃ¶sterir.
    # temp_thinking_msg = await interaction.followup.send(thinking_message_content)

    # KiÅŸilik: Bu tÃ¼r komutlarda sunucu kiÅŸiliÄŸi uygulanMAmalÄ±. Sadece mention sohbetlerinde.
    ai_response = await ask_gemini_core(
        prompt_parts_for_ai,
        user_id=user_id,
        target_language_code=user_lang,
        apply_guild_chat_personality=False, # Komutlarda sunucu kiÅŸiliÄŸi yok
        guild_id=interaction.guild_id
    )

    # if temp_thinking_msg:
    #     try: await temp_thinking_msg.delete()
    #     except: pass

    if ai_response:
        # YanÄ±tÄ± 2000 karakterlik embed'lere bÃ¶l (veya direkt mesaja)
        # Åimdilik tek bir embed/mesajda yollayalÄ±m, gerekirse bÃ¶lme eklenebilir.
        # EÄŸer yanÄ±t Ã§ok uzunsa Discord hata verecektir. ask_gemini_core'daki max_output_tokens bunu bir nebze Ã¶nler.
        response_embed = Embed(description=ai_response, color=discord.Color.og_blurple())
        response_embed.set_author(name=f"{EMOJIS['ai']} OmniVerse AI Response", icon_url=client.user.avatar.url if client.user.avatar else None)
        response_embed.set_footer(text=f"Requested by {interaction.user.display_name}")
        await interaction.followup.send(embed=response_embed)
    else:
        await interaction.followup.send(get_lang_string(user_id, "error_ai_failed_to_respond_command", default="AI could not generate a response for this command."))


@tree.command(
    name="summarize",
    description="Summarizes text, links, or uploaded documents.",
    description_localizations=get_all_localized_descriptions("summarize")
)
@app_commands.describe(
    text_or_link="Text to summarize or a link to a webpage/document.",
    file="Upload a file (PDF, TXT, image) to summarize."
)
async def summarize_slash(interaction: Interaction, text_or_link: str = None, file: Attachment = None):
    user_id = interaction.user.id
    prompt_parts = []
    error_msg_key_summarize = None

    if not text_or_link and not file:
        await interaction.response.send_message(get_lang_string(user_id, "error_summarize_no_input", default="Please provide text, a link, or upload a file to summarize."), ephemeral=True)
        return

    # GeÃ§ici bir mesaj oluÅŸturup AI iÃ§in inputlarÄ± oradan alalÄ±m
    temp_message_content = text_or_link if text_or_link else ""
    temp_attachments = [file] if file else []
    
    # GerÃ§ek bir Message objesi oluÅŸturmak yerine, iÃ§eriÄŸi doÄŸrudan iÅŸleyelim.
    # process_message_for_ai_input normalde Message objesi bekler.
    # Bu yÃ¼zden manuel olarak AI'a gÃ¶nderilecek parÃ§alarÄ± oluÅŸturalÄ±m.

    if temp_message_content:
        # Linkleri iÅŸle
        url_pattern = r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+"
        urls_found = re.findall(url_pattern, temp_message_content)
        async with aiohttp.ClientSession() as session:
            for url in urls_found:
                url_data = await fetch_url_content(session, url)
                if url_data:
                    if "text" in url_data: prompt_parts.append(f"\nContent from Link ({url}):\n{url_data['text']}\n")
                    if "image_url" in url_data and url_data["image_url"]:
                        img_link_data = await fetch_url_content(session, url_data["image_url"])
                        if img_link_data and "image_bytes" in img_link_data:
                            try: prompt_parts.append(Image.open(BytesIO(img_link_data["image_bytes"])))
                            except: pass
                    elif "image_bytes" in url_data: # DoÄŸrudan resim linki
                        try: prompt_parts.append(Image.open(BytesIO(url_data["image_bytes"])))
                        except: pass
        # Link dÄ±ÅŸÄ±ndaki metni de ekle (eÄŸer varsa)
        non_link_text = re.sub(url_pattern, "", temp_message_content).strip()
        if non_link_text:
            prompt_parts.insert(0, non_link_text) # KullanÄ±cÄ±nÄ±n girdiÄŸi metni baÅŸa al

    if file:
        MAX_FILE_SIZE_BYTES = 8 * 1024 * 1024
        if file.size > MAX_FILE_SIZE_BYTES:
            await interaction.response.send_message(get_lang_string(user_id, "error_file_too_large", max_size_mb=8), ephemeral=True)
            return
        
        file_bytes = await file.read()
        content_type = file.content_type.lower() if file.content_type else ""

        if content_type.startswith("image/"):
            try: prompt_parts.append(Image.open(BytesIO(file_bytes)))
            except: error_msg_key_summarize = "error_file_image_process"
        elif content_type == "application/pdf" and PdfReader:
            pdf_text = await extract_text_from_pdf_bytes(file_bytes, user_id)
            if pdf_text: prompt_parts.append(f"\nContent from PDF ({file.filename}):\n{pdf_text}\n")
            else: error_msg_key_summarize = "error_pdf_read"
        elif content_type.startswith("text/plain"):
            try: prompt_parts.append(f"\nContent from TXT ({file.filename}):\n{file_bytes.decode('utf-8', errors='ignore')}\n")
            except: error_msg_key_summarize = "error_file_txt_read"
        else:
            error_msg_key_summarize = "error_unsupported_file_summarize"
            # await interaction.response.send_message(get_lang_string(user_id, "error_unsupported_file", file_type=content_type), ephemeral=True)
            # return

    if error_msg_key_summarize:
        await interaction.response.send_message(get_lang_string(user_id, error_msg_key_summarize), ephemeral=True)
        return

    if not prompt_parts:
        await interaction.response.send_message(get_lang_string(user_id, "error_summarize_no_valid_content", default="No valid content found to summarize."), ephemeral=True)
        return

    # AI'a gÃ¶nderilecek asÄ±l prompt'u oluÅŸtur
    summarize_instruction = get_lang_string(user_id, "ai_prompt_summarize_instruction", default="Please summarize the following content concisely:")
    final_ai_prompt_parts = [summarize_instruction] + prompt_parts

    await handle_ai_command_interaction(interaction, "summarize", final_ai_prompt_parts)


@tree.command(
    name="translate",
    description="Translates text or content from images/links to a specified language.",
    description_localizations=get_all_localized_descriptions("translate")
)
@app_commands.describe(
    target_language="The language code to translate to (e.g., en, tr, fr).",
    text_or_link="Text to translate or a link to content.",
    file="Upload an image file containing text to translate."
)
@app_commands.choices(target_language=[
    app_commands.Choice(name=f"{data['flag']} {data['name']}", value=code) for code, data in SUPPORTED_LANGUAGES.items()
])
async def translate_slash(interaction: Interaction, target_language: str, text_or_link: str = None, file: Attachment = None):
    user_id = interaction.user.id
    if not text_or_link and not file:
        await interaction.response.send_message(get_lang_string(user_id, "error_translate_no_input", default="Please provide text, a link, or an image file to translate."), ephemeral=True)
        return

    prompt_parts_translate = []
    error_msg_key_translate = None

    # Metin veya link iÅŸleme (summarize'a benzer)
    if text_or_link:
        url_pattern = r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+"
        urls_found = re.findall(url_pattern, text_or_link)
        async with aiohttp.ClientSession() as session:
            for url in urls_found:
                url_data = await fetch_url_content(session, url)
                if url_data:
                    if "text" in url_data: prompt_parts_translate.append(f"\nContent from Link ({url}):\n{url_data['text']}\n")
                    if "image_url" in url_data and url_data["image_url"]:
                        img_link_data = await fetch_url_content(session, url_data["image_url"])
                        if img_link_data and "image_bytes" in img_link_data:
                            try: prompt_parts_translate.append(Image.open(BytesIO(img_link_data["image_bytes"])))
                            except: pass
                    elif "image_bytes" in url_data:
                        try: prompt_parts_translate.append(Image.open(BytesIO(url_data["image_bytes"])))
                        except: pass
        non_link_text_tr = re.sub(url_pattern, "", text_or_link).strip()
        if non_link_text_tr:
            prompt_parts_translate.insert(0, non_link_text_tr)

    # Dosya iÅŸleme (sadece resim)
    if file:
        MAX_FILE_SIZE_BYTES = 8 * 1024 * 1024
        if file.size > MAX_FILE_SIZE_BYTES:
            await interaction.response.send_message(get_lang_string(user_id, "error_file_too_large", max_size_mb=8), ephemeral=True)
            return
        
        content_type = file.content_type.lower() if file.content_type else ""
        if content_type.startswith("image/"):
            try:
                file_bytes = await file.read()
                prompt_parts_translate.append(Image.open(BytesIO(file_bytes)))
            except:
                error_msg_key_translate = "error_file_image_process"
        else:
            error_msg_key_translate = "error_unsupported_file_translate_image_only" # Ã‡eviri iÃ§in sadece resim dosyasÄ± destekleniyor

    if error_msg_key_translate:
        await interaction.response.send_message(get_lang_string(user_id, error_msg_key_translate), ephemeral=True)
        return

    if not prompt_parts_translate:
        await interaction.response.send_message(get_lang_string(user_id, "error_translate_no_valid_content", default="No valid content found to translate."), ephemeral=True)
        return

    target_lang_name = SUPPORTED_LANGUAGES.get(target_language, {}).get("name", target_language)
    translate_instruction = get_lang_string(user_id, "ai_prompt_translate_instruction", target_language_name=target_lang_name, target_language_code=target_language, default=f"Please translate the following content into {target_lang_name} (code: {target_language}). If there are images, translate any text found in them as well:")
    final_ai_prompt_parts_tr = [translate_instruction] + prompt_parts_translate
    
    await handle_ai_command_interaction(interaction, "translate", final_ai_prompt_parts_tr)


@tree.command(
    name="analyzedocument",
    description="Analyzes an uploaded document (PDF, TXT).",
    description_localizations=get_all_localized_descriptions("analyzedocument")
)
@app_commands.describe(
    file="The document file (PDF or TXT) to analyze.",
    question="Optional: A specific question to ask about the document."
)
async def analyzedocument_slash(interaction: Interaction, file: Attachment, question: str = None):
    user_id = interaction.user.id
    MAX_FILE_SIZE_BYTES = 8 * 1024 * 1024 # PDF/TXT iÃ§in de bir limit olmalÄ±
    if file.size > MAX_FILE_SIZE_BYTES:
        await interaction.response.send_message(get_lang_string(user_id, "error_file_too_large", max_size_mb=8), ephemeral=True)
        return

    file_bytes = await file.read()
    content_type = file.content_type.lower() if file.content_type else ""
    doc_text_content = None
    error_key_doc = None

    if content_type == "application/pdf" and PdfReader:
        doc_text_content = await extract_text_from_pdf_bytes(file_bytes, user_id)
        if not doc_text_content: error_key_doc = "error_pdf_read"
    elif content_type.startswith("text/plain"):
        try:
            doc_text_content = file_bytes.decode("utf-8", errors="ignore")
        except:
            error_key_doc = "error_file_txt_read"
    else:
        error_key_doc = "error_unsupported_file" # Genel desteklenmeyen dosya

    if error_key_doc:
        await interaction.response.send_message(get_lang_string(user_id, error_key_doc, file_type=content_type), ephemeral=True)
        return
    
    if not doc_text_content or not doc_text_content.strip():
        await interaction.response.send_message(get_lang_string(user_id, "error_document_no_text", filename=file.filename, default=f"Could not extract any text from the document: {file.filename}."), ephemeral=True)
        return

    # AI prompt'u
    analyze_instruction_key = "ai_prompt_analyzedocument_instruction_no_q"
    default_instruction_no_q = f"Please analyze the following document content from '{file.filename}':"
    if question:
        analyze_instruction_key = "ai_prompt_analyzedocument_instruction_with_q"
        default_instruction_with_q = f"Please analyze the following document content from '{file.filename}' and answer this question: '{question}':"
    
    analyze_instruction = get_lang_string(user_id, analyze_instruction_key, filename=file.filename, question=question, default=default_instruction_with_q if question else default_instruction_no_q)

    # DÃ¶kÃ¼man metnini AI'Ä±n iÅŸleyebileceÄŸi bir boyuta kÄ±rp (Ã¶rn. ilk X karakter)
    MAX_DOC_TEXT_FOR_AI = 100000 # Gemini iÃ§in token limiti daha yÃ¼ksek olabilir, gÃ¼venli bir karakter limiti
    if len(doc_text_content) > MAX_DOC_TEXT_FOR_AI:
        doc_text_content_for_ai = doc_text_content[:MAX_DOC_TEXT_FOR_AI] + "\n...(Document content truncated due to length)..."
    else:
        doc_text_content_for_ai = doc_text_content

    final_ai_prompt_parts_doc = [analyze_instruction, doc_text_content_for_ai]
    await handle_ai_command_interaction(interaction, "analyzedocument", final_ai_prompt_parts_doc, is_multimodal_capable_command=False) # Sadece metin


@tree.command(
    name="analyzechat",
    description="Analyzes recent messages in the current channel.",
    description_localizations=get_all_localized_descriptions("analyzechat")
)
@app_commands.describe(question="Optional: A specific question to ask about the chat.")
async def analyzechat_slash(interaction: Interaction, question: str = None):
    user_id = interaction.user.id
    MESSAGE_SCAN_LIMIT = 250 # KullanÄ±cÄ±nÄ±n istediÄŸi limit

    await interaction.response.defer() # Bu iÅŸlem uzun sÃ¼rebilir

    chat_history_texts = []
    try:
        async for msg_hist in interaction.channel.history(limit=MESSAGE_SCAN_LIMIT, oldest_first=False): # En sondan baÅŸa doÄŸru
            if msg_hist.author.bot: continue # Bot mesajlarÄ±nÄ± atla
            
            text_entry = f"[{msg_hist.created_at.strftime('%Y-%m-%d %H:%M')}] {msg_hist.author.display_name}: {msg_hist.clean_content}"
            # Eklentiler veya embedler hakkÄ±nda bilgi eklenebilir, ama metin odaklÄ± analiz iÃ§in ÅŸimdilik sadece clean_content
            if msg_hist.embeds: text_entry += " [has embeds]"
            if msg_hist.attachments: text_entry += f" [{len(msg_hist.attachments)} attachments]"
            chat_history_texts.append(text_entry)
        chat_history_texts.reverse() # Kronolojik sÄ±raya getir (eskiden yeniye)
    except discord.Forbidden:
        await interaction.followup.send(get_lang_string(user_id, "error_analyzechat_permission", channel_name=interaction.channel.mention, default=f"I don't have permission to read message history in {interaction.channel.mention}."), ephemeral=True)
        return
    except Exception as e:
        logger.error(f"Sohbet geÃ§miÅŸi okunurken hata (/analyzechat): {e}")
        await interaction.followup.send(get_lang_string(user_id, "error_analyzechat_read_failed", default="Failed to read chat history."), ephemeral=True)
        return

    if not chat_history_texts:
        await interaction.followup.send(get_lang_string(user_id, "error_analyzechat_no_messages", limit=MESSAGE_SCAN_LIMIT, default=f"No recent messages found to analyze in the last {MESSAGE_SCAN_LIMIT} messages."), ephemeral=True)
        return

    full_chat_log = "\n".join(chat_history_texts)
    
    # AI prompt'u
    analyze_chat_instruction_key = "ai_prompt_analyzechat_instruction_no_q"
    default_chat_instr_no_q = "Please analyze the following chat conversation from this channel. Focus on main topics, discussion dynamics, and overall sentiment:"
    if question:
        analyze_chat_instruction_key = "ai_prompt_analyzechat_instruction_with_q"
        default_chat_instr_with_q = f"Please analyze the following chat conversation from this channel and answer this question: '{question}':"
    
    chat_instruction = get_lang_string(user_id, analyze_chat_instruction_key, question=question, default=default_chat_instr_with_q if question else default_chat_instr_no_q)

    # Sohbet logunu AI'Ä±n iÅŸleyebileceÄŸi bir boyuta kÄ±rp
    MAX_CHAT_LOG_FOR_AI = 100000
    if len(full_chat_log) > MAX_CHAT_LOG_FOR_AI:
        full_chat_log_for_ai = full_chat_log[-MAX_CHAT_LOG_FOR_AI:] + "\n...(Chat log truncated due to length)..." # Sondan kÄ±rp ki en yeni mesajlar kalsÄ±n
    else:
        full_chat_log_for_ai = full_chat_log
        
    final_ai_prompt_parts_chat = [chat_instruction, full_chat_log_for_ai]
    await handle_ai_command_interaction(interaction, "analyzechat", final_ai_prompt_parts_chat, is_multimodal_capable_command=False)


@tree.command(
    name="analyzeuser",
    description="Analyzes the recent chat messages of a user in the current channel.",
    description_localizations=get_all_localized_descriptions("analyzeuser")
)
@app_commands.describe(
    user_to_analyze="The user whose messages you want to analyze.",
    question="Optional: A specific question to ask about the user's messages."
)
async def analyzeuser_slash(interaction: Interaction, user_to_analyze: discord.Member, question: str = None):
    user_id = interaction.user.id
    TARGET_USER_MESSAGE_LIMIT = 150 # KullanÄ±cÄ±nÄ±n istediÄŸi limit
    OVERALL_SCAN_LIMIT_FOR_USER = 2500 # Bu kadar mesaj iÃ§inde kullanÄ±cÄ±nÄ±n mesajlarÄ±nÄ± ara

    if user_to_analyze.bot:
        await interaction.response.send_message(get_lang_string(user_id, "error_analyzeuser_is_bot", default="Cannot analyze messages of a bot."), ephemeral=True)
        return

    await interaction.response.defer()

    user_messages_collected = []
    try:
        count = 0
        async for msg_hist_u in interaction.channel.history(limit=OVERALL_SCAN_LIMIT_FOR_USER, oldest_first=False):
            if msg_hist_u.author.id == user_to_analyze.id:
                if msg_hist_u.clean_content: # Sadece metin iÃ§eren mesajlarÄ± al
                    text_entry_u = f"[{msg_hist_u.created_at.strftime('%Y-%m-%d %H:%M')}] {msg_hist_u.clean_content}"
                    # Eklentiler/embedler de eklenebilir
                    if msg_hist_u.embeds: text_entry_u += " [has embeds]"
                    if msg_hist_u.attachments: text_entry_u += f" [{len(msg_hist_u.attachments)} attachments]"
                    user_messages_collected.append(text_entry_u)
                    count += 1
                    if count >= TARGET_USER_MESSAGE_LIMIT:
                        break
        user_messages_collected.reverse() # Kronolojik
    except discord.Forbidden:
        await interaction.followup.send(get_lang_string(user_id, "error_analyzeuser_permission", channel_name=interaction.channel.mention, default=f"I don't have permission to read message history in {interaction.channel.mention}."), ephemeral=True)
        return
    except Exception as e:
        logger.error(f"KullanÄ±cÄ± mesajlarÄ± okunurken hata (/analyzeuser): {e}")
        await interaction.followup.send(get_lang_string(user_id, "error_analyzeuser_read_failed", default="Failed to read user's messages."), ephemeral=True)
        return

    if not user_messages_collected:
        await interaction.followup.send(get_lang_string(user_id, "error_analyzeuser_no_messages", user_name=user_to_analyze.display_name, limit=TARGET_USER_MESSAGE_LIMIT, scan_limit=OVERALL_SCAN_LIMIT_FOR_USER, default=f"No recent text messages found from {user_to_analyze.display_name} to analyze in the last {TARGET_USER_MESSAGE_LIMIT} (scanned up to {OVERALL_SCAN_LIMIT_FOR_USER} channel messages)."), ephemeral=True)
        return
        
    full_user_log = "\n".join(user_messages_collected)

    # AI prompt'u
    analyze_user_instr_key = "ai_prompt_analyzeuser_instruction_no_q"
    default_user_instr_no_q = f"Please analyze the following messages from user '{user_to_analyze.display_name}'. Focus on their communication style, common topics, and general tone:"
    if question:
        analyze_user_instr_key = "ai_prompt_analyzeuser_instruction_with_q"
        default_user_instr_with_q = f"Please analyze the following messages from user '{user_to_analyze.display_name}' and answer this question: '{question}':"

    user_instr = get_lang_string(user_id, analyze_user_instr_key, user_name=user_to_analyze.display_name, question=question, default=default_user_instr_with_q if question else default_user_instr_no_q)
    
    MAX_USER_LOG_FOR_AI = 100000
    if len(full_user_log) > MAX_USER_LOG_FOR_AI:
        full_user_log_for_ai = full_user_log[:MAX_USER_LOG_FOR_AI] + "\n...(User message log truncated due to length)..." # BaÅŸtan kÄ±rp (en eski mesajlar)
    else:
        full_user_log_for_ai = full_user_log

    final_ai_prompt_parts_user = [user_instr, full_user_log_for_ai]
    await handle_ai_command_interaction(interaction, "analyzeuser", final_ai_prompt_parts_user, is_multimodal_capable_command=False)


# --- Oyun KomutlarÄ± ---
# TicTacToe Oyunu
class TicTacToeButton(ui.Button['TicTacToeView']):
    def __init__(self, x: int, y: int, row: int):
        super().__init__(style=ButtonStyle.secondary, label='\u200b', row=row) # BoÅŸluk karakteri
        self.x = x
        self.y = y

    async def callback(self, interaction: Interaction):
        view: 'TicTacToeView' = self.view
        if not view: return

        if interaction.user.id != view.current_player_obj.id:
            await interaction.response.send_message(get_lang_string(interaction.user.id, "tictactoe_not_your_turn", default="It's not your turn!"), ephemeral=True)
            return

        if view.board[self.y][self.x] != view.EMPTY_CELL:
            await interaction.response.send_message(get_lang_string(interaction.user.id, "tictactoe_cell_taken", default="This cell is already taken!"), ephemeral=True)
            return

        if view.game_over:
            await interaction.response.defer() # Oyun bittiyse bir ÅŸey yapma
            return

        view.board[self.y][self.x] = view.current_player_marker
        self.label = "X" if view.current_player_marker == view.PLAYER_X_MARKER else "O"
        self.style = ButtonStyle.success if view.current_player_marker == view.PLAYER_X_MARKER else ButtonStyle.danger
        self.disabled = True
        
        winner = view.check_winner()
        if winner is not None: # Kazanan var veya berabere
            await view.end_game(interaction, winner)
        else: # Oyun devam ediyor
            view.switch_player()
            await interaction.response.edit_message(embed=view.create_embed(), view=view)
            # EÄŸer AI sÄ±rasÄ±ysa, AI hamlesini yap
            if view.game_mode == "ai" and view.current_player_obj == client.user:
                await view.ai_move(interaction)


class TicTacToeView(ui.View):
    EMPTY_CELL = 0
    PLAYER_X_MARKER = 1 # Genellikle insan oyuncu 1
    PLAYER_O_MARKER = 2 # Ä°nsan oyuncu 2 veya AI

    def __init__(self, interaction_user: discord.Member, opponent: discord.Member | None, game_mode: str): # game_mode: "user" veya "ai"
        super().__init__(timeout=300.0) # 5 dakika timeout
        self.interaction_user = interaction_user # Oyunu baÅŸlatan
        self.opponent = opponent # Rakip (user modunda) veya None (AI modunda)
        self.game_mode = game_mode
        self.message: discord.Message | None = None

        self.player_x: discord.Member = interaction_user
        self.player_o: discord.Member | None = None # O ya AI ya da opponent olacak

        if game_mode == "ai":
            self.player_o = client.user # AI botun kendisi
        else: # game_mode == "user"
            self.player_o = opponent
        
        self.current_player_obj: discord.Member = self.player_x # X baÅŸlar
        self.current_player_marker = self.PLAYER_X_MARKER
        
        self.board = [[self.EMPTY_CELL for _ in range(3)] for _ in range(3)]
        self.game_over = False

        # ButonlarÄ± ekle
        for y_coord in range(3):
            for x_coord in range(3):
                self.add_item(TicTacToeButton(x_coord, y_coord, row=y_coord))
    
    def create_embed(self) -> Embed:
        title = f"{EMOJIS['game']} Tic-Tac-Toe: {self.player_x.display_name} (X) vs "
        if self.game_mode == "ai":
            title += f"{BOT_NAME} (O)"
        else:
            title += f"{self.player_o.display_name} (O)"
        
        description = ""
        if self.game_over:
            # SonuÃ§ mesajÄ± end_game iÃ§inde eklenecek
            pass
        else:
            current_marker_char = "X" if self.current_player_marker == self.PLAYER_X_MARKER else "O"
            description = f"Turn: **{self.current_player_obj.display_name}** ({current_marker_char})"

        embed = Embed(title=title, description=description, color=discord.Color.blurple())
        # TahtayÄ± da gÃ¶sterebiliriz (isteÄŸe baÄŸlÄ±)
        # board_display = "\n".join([" ".join([("X" if cell == self.PLAYER_X_MARKER else ("O" if cell == self.PLAYER_O_MARKER else "â¬œ")) for cell in row]) for row in self.board])
        # embed.add_field(name="Board", value=f"```\n{board_display}\n```", inline=False)
        return embed

    def check_winner(self):
        # SatÄ±rlarÄ±, sÃ¼tunlarÄ± ve kÃ¶ÅŸegenleri kontrol et
        lines = []
        lines.extend(self.board) # SatÄ±rlar
        lines.extend([[self.board[j][i] for j in range(3)] for i in range(3)]) # SÃ¼tunlar
        lines.append([self.board[i][i] for i in range(3)]) # Ana kÃ¶ÅŸegen
        lines.append([self.board[i][2-i] for i in range(3)]) # Ters kÃ¶ÅŸegen

        for line in lines:
            if line[0] == line[1] == line[2] != self.EMPTY_CELL:
                return line[0] # Kazanan marker'Ä± dÃ¶ndÃ¼r (1 veya 2)

        # Beraberlik kontrolÃ¼ (tÃ¼m hÃ¼creler doluysa)
        if all(cell != self.EMPTY_CELL for row in self.board for cell in row):
            return 3 # Berabere kodu
        return None # Oyun devam ediyor

    def switch_player(self):
        if self.current_player_marker == self.PLAYER_X_MARKER:
            self.current_player_obj = self.player_o
            self.current_player_marker = self.PLAYER_O_MARKER
        else:
            self.current_player_obj = self.player_x
            self.current_player_marker = self.PLAYER_X_MARKER
            
    async def ai_move(self, interaction_context: Interaction):
        if self.game_over or self.current_player_obj != client.user:
            return

        await asyncio.sleep(random.uniform(0.5, 1.5)) # AI dÃ¼ÅŸÃ¼nme sÃ¼resi

        empty_cells = []
        for r_idx, row in enumerate(self.board):
            for c_idx, cell in enumerate(row):
                if cell == self.EMPTY_CELL:
                    empty_cells.append((r_idx, c_idx))
        
        if not empty_cells: return # Hamle yapacak yer yok (beraberlik durumu check_winner'da yakalanmalÄ±)

        # Basit AI: Rastgele boÅŸ bir hÃ¼cre seÃ§
        # Daha geliÅŸmiÅŸ AI iÃ§in Minimax algoritmasÄ± eklenebilir
        ai_r, ai_c = random.choice(empty_cells)
        
        self.board[ai_r][ai_c] = self.PLAYER_O_MARKER # AI her zaman O olsun
        
        # Butonu gÃ¼ncelle
        button_to_update: TicTacToeButton | None = None
        for item in self.children:
            if isinstance(item, TicTacToeButton) and item.x == ai_c and item.y == ai_r:
                button_to_update = item
                break
        
        if button_to_update:
            button_to_update.label = "O"
            button_to_update.style = ButtonStyle.danger
            button_to_update.disabled = True

        winner = self.check_winner()
        if winner is not None:
            await self.end_game(interaction_context, winner, ai_played_last=True)
        else:
            self.switch_player() # SÄ±rayÄ± insana geri ver
            if self.message:
                await self.message.edit(embed=self.create_embed(), view=self)
            # EÄŸer interaction_context bir mesajÄ±n yanÄ±tÄ±ysa (bu durumda AI hamlesi iÃ§in deÄŸil)
            # o zaman interaction_context.edit_original_response() kullanÄ±labilir.
            # Ancak AI hamlesi genellikle bir buton callback'i sonrasÄ± olacaÄŸÄ± iÃ§in message.edit daha doÄŸru.


    async def end_game(self, interaction: Interaction, winner_marker: int, ai_played_last: bool = False):
        self.game_over = True
        for item in self.children:
            if isinstance(item, ui.Button):
                item.disabled = True
        
        result_message = ""
        winner_obj: discord.Member | None = None
        won_against_ai = False

        if winner_marker == self.PLAYER_X_MARKER: # X kazandÄ±
            winner_obj = self.player_x
            result_message = f"{EMOJIS['party']} {self.player_x.mention} (X) wins!"
            if self.game_mode == "ai": won_against_ai = True
        elif winner_marker == self.PLAYER_O_MARKER: # O kazandÄ±
            winner_obj = self.player_o
            if self.game_mode == "ai": # AI kazandÄ±
                result_message = f"{EMOJIS['ai']} {BOT_NAME} (O) wins!"
            else: # DiÄŸer kullanÄ±cÄ± kazandÄ±
                result_message = f"{EMOJIS['party']} {self.player_o.mention} (O) wins!"
        elif winner_marker == 3: # Berabere
            result_message = f"{EMOJIS['info']} It's a Tie!"
        
        if won_against_ai and winner_obj == self.interaction_user: # Oyunu baÅŸlatan AI'Ä± yendi
            await grant_credits_if_needed(winner_obj.id, 1, "TicTacToe AI Win")
            result_message += f"\n{get_lang_string(winner_obj.id, 'tictactoe_vs_ai_win')}"

        final_embed = self.create_embed() # BaÅŸlÄ±ÄŸÄ± ve mevcut durumu alÄ±r
        final_embed.description = result_message # AÃ§Ä±klamayÄ± sonuÃ§la gÃ¼nceller
        final_embed.color = discord.Color.green() if winner_obj else discord.Color.orange()

        # Interaction yanÄ±tlanmÄ±ÅŸsa edit, deÄŸilse response.
        # EÄŸer AI son hamleyi yaptÄ±ysa, bu bir buton callback'i olmayabilir.
        if not ai_played_last: # Ä°nsan oyuncu son hamleyi yaptÄ±
            if not interaction.response.is_done():
                await interaction.response.edit_message(embed=final_embed, view=self)
            elif self.message:
                await self.message.edit(embed=final_embed, view=self)
        elif self.message: # AI son hamleyi yaptÄ±, self.message Ã¼zerinden gÃ¼ncelle
            await self.message.edit(embed=final_embed, view=self)
        
        self.stop()

    async def on_timeout(self):
        if not self.game_over and self.message:
            self.game_over = True
            for item in self.children:
                if isinstance(item, ui.Button): item.disabled = True
            
            timeout_embed = self.create_embed()
            timeout_embed.description = get_lang_string(self.interaction_user.id, "tictactoe_timeout", default="Game timed out!")
            timeout_embed.color = discord.Color.red()
            try:
                await self.message.edit(embed=timeout_embed, view=self)
            except discord.NotFound: pass
            except Exception as e_timeout: logger.warning(f"TicTacToe timeout mesajÄ± dÃ¼zenlenemedi: {e_timeout}")
        self.stop()


@tree.command(
    name="tictactoe",
    description="Play Tic-Tac-Toe against AI or another user.",
    description_localizations=get_all_localized_descriptions("tictactoe")
)
@app_commands.describe(opponent="The user to play against (leave empty to play against AI).")
async def tictactoe_slash(interaction: Interaction, opponent: discord.Member = None):
    user_lang = get_user_lang_from_interaction(interaction)

    if opponent and opponent.bot:
        await interaction.response.send_message(get_lang_string(interaction.user.id, "tictactoe_opponent_is_bot", default="You cannot play Tic-Tac-Toe against another bot."), ephemeral=True)
        return
    if opponent and opponent == interaction.user:
        await interaction.response.send_message(get_lang_string(interaction.user.id, "tictactoe_play_with_self", default="You cannot play Tic-Tac-Toe against yourself."), ephemeral=True)
        return

    game_mode = "ai" if opponent is None else "user"
    
    # Kredi kontrolÃ¼ (sadece AI'a karÅŸÄ± oynanÄ±yorsa, oyun baÅŸÄ±nda deÄŸil, kazanÄ±rsa verilecek)
    # Bu komutun kendisi kredi harcamamalÄ±.

    view = TicTacToeView(interaction.user, opponent, game_mode)
    initial_embed = view.create_embed()
    
    content_msg = ""
    if game_mode == "user" and opponent:
        content_msg = get_lang_string(interaction.user.id, "tictactoe_challenge_user", opponent_mention=opponent.mention, challenger_mention=interaction.user.mention, default=f"{opponent.mention}, {interaction.user.mention} challenges you to a game of Tic-Tac-Toe!")
    elif game_mode == "ai":
        content_msg = get_lang_string(interaction.user.id, "tictactoe_challenge_ai", user_mention=interaction.user.mention, bot_name=BOT_NAME, default=f"{interaction.user.mention} is challenging {BOT_NAME} to a game of Tic-Tac-Toe!")

    await interaction.response.send_message(content=content_msg, embed=initial_embed, view=view)
    view.message = await interaction.original_response()


# --- Komut AÄŸacÄ± Hata YakalayÄ±cÄ±sÄ± ---
@tree.error
async def on_app_command_error(interaction: Interaction, error: app_commands.AppCommandError):
    user_id_for_error_lang = interaction.user.id if interaction.user else DEVELOPER_IDS[0] # Fallback
    logger.error(f"Slash Komut HatasÄ±: {interaction.command.name if interaction.command else 'Bilinmeyen Komut'} - TÃ¼r: {type(error).__name__} - Hata: {error}", exc_info=True)
    
    embed = Embed(title=f"{EMOJIS['error']} Command Error!", color=discord.Color.red(), timestamp=datetime.now(timezone.utc))
    
    if isinstance(error, app_commands.CommandNotFound):
        embed.description = get_lang_string(user_id_for_error_lang, "error_command_not_found", default="Command not found.")
    elif isinstance(error, app_commands.MissingPermissions):
        embed.description = get_lang_string(user_id_for_error_lang, "error_no_permission")
    elif isinstance(error, app_commands.BotMissingPermissions):
        embed.description = get_lang_string(user_id_for_error_lang, "error_bot_no_permission", permissions=', '.join(error.missing_permissions))
    elif isinstance(error, app_commands.CommandOnCooldown):
        embed.description = get_lang_string(user_id_for_error_lang, "error_cooldown", seconds=error.retry_after)
    elif isinstance(error, app_commands.CheckFailure): # Genel check hatasÄ±
        embed.description = get_lang_string(user_id_for_error_lang, "error_check_failure", default="You do not meet the conditions to use this command.")
    # ... diÄŸer Ã¶zel hata tÃ¼rleri eklenebilir ...
    else:
        embed.description = get_lang_string(user_id_for_error_lang, "error_generic_command_processing", error_message=str(error), default=f"An unexpected error occurred while processing the command: `{str(error)}`")
    
    embed.set_footer(text=f"{BOT_NAME} v{VERSION}")
    try:
        if interaction.response.is_done():
            await interaction.followup.send(embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message(embed=embed, ephemeral=True)
    except Exception as e_err_send:
        logger.error(f"Komut hata mesajÄ± gÃ¶nderilemedi: {e_err_send}")


# --- Botu BaÅŸlatma ---
if __name__ == "__main__":
    DISCORD_TOKEN = os.environ.get("DISCORD_TOKEN")
    if not DISCORD_TOKEN:
        logger.critical("HATA: DISCORD_TOKEN ortam deÄŸiÅŸkeni ayarlanmamÄ±ÅŸ!")
    elif not GEMINI_API_KEY: # Sadece uyarÄ±, AI Ã¶zellikleri Ã§alÄ±ÅŸmaz
        logger.warning("UYARI: GEMINI_API_KEY ortam deÄŸiÅŸkeni ayarlanmamÄ±ÅŸ! AI Ã¶zellikleri devre dÄ±ÅŸÄ± olacak.")

    if DISCORD_TOKEN:
        try:
            client.run(DISCORD_TOKEN, log_handler=None) # Discord.py kendi log handler'Ä±nÄ± kullanÄ±r
        except discord.LoginFailure:
            logger.critical("Discord tokeni geÃ§ersiz. LÃ¼tfen tokeninizi kontrol edin.")
        except discord.PrivilegedIntentsRequired:
             logger.critical("YetkilendirilmiÅŸ Intent'ler (Privileged Intents) etkinleÅŸtirilmemiÅŸ. LÃ¼tfen Discord Developer Portal'dan botunuz iÃ§in 'Presence Intent', 'Server Members Intent' ve 'Message Content Intent' ayarlarÄ±nÄ± aÃ§Ä±n.")
        except Exception as e_run:
            logger.critical(f"Bot baÅŸlatÄ±lÄ±rken kritik bir hata oluÅŸtu: {e_run}", exc_info=True)